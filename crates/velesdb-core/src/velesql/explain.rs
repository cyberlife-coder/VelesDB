//! Query plan explanation for `VelesQL`.
//!
//! This module provides EXPLAIN functionality to display query execution plans.
//!
//! # Example
//!
//! ```ignore
//! use velesdb_core::velesql::{Parser, QueryPlan};
//!
//! let query = Parser::parse("SELECT * FROM docs WHERE vector NEAR $v LIMIT 10")?;
//! let plan = QueryPlan::from_select(&query.select);
//! println!("{}", plan.to_tree());
//! ```

mod formatter;

use serde::{Deserialize, Serialize};

use super::ast::{Condition, SelectStatement};
use crate::collection::search::query::match_planner::{
    CollectionStats, MatchExecutionStrategy, MatchQueryPlanner,
};
use crate::velesql::MatchClause;

/// Query execution plan generated by EXPLAIN.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct QueryPlan {
    /// Root node of the plan tree.
    pub root: PlanNode,
    /// Estimated execution cost in milliseconds.
    pub estimated_cost_ms: f64,
    /// Index type used (if any).
    pub index_used: Option<IndexType>,
    /// Filter strategy.
    pub filter_strategy: FilterStrategy,
}

/// A node in the query execution plan tree.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum PlanNode {
    /// Vector similarity search operation.
    VectorSearch(VectorSearchPlan),
    /// Metadata filter operation.
    Filter(FilterPlan),
    /// Limit results.
    Limit(LimitPlan),
    /// Offset skip.
    Offset(OffsetPlan),
    /// Table scan (no index).
    TableScan(TableScanPlan),
    /// Property index lookup (O(1) instead of scan).
    IndexLookup(IndexLookupPlan),
    /// Sequential operations.
    Sequence(Vec<PlanNode>),
    /// MATCH graph traversal (EPIC-046 US-004).
    MatchTraversal(MatchTraversalPlan),
    /// NEAR_FUSED multi-vector fused search (VP-012, Phase 7).
    FusedSearch(FusedSearchPlan),
    /// Cross-store combined Vector + Graph MATCH (VP-010, Phase 7).
    CrossStoreSearch(CrossStoreSearchPlan),
}

/// Vector search plan details.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct VectorSearchPlan {
    /// Collection name.
    pub collection: String,
    /// `ef_search` parameter (for HNSW).
    pub ef_search: u32,
    /// Number of candidates to retrieve.
    pub candidates: u32,
}

/// Filter plan details.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct FilterPlan {
    /// Filter conditions as string representation.
    pub conditions: String,
    /// Estimated selectivity (0.0 - 1.0).
    pub selectivity: f64,
}

/// Limit plan details.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct LimitPlan {
    /// Maximum number of results.
    pub count: u64,
}

/// Offset plan details.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct OffsetPlan {
    /// Number of results to skip.
    pub count: u64,
}

/// Table scan plan (no index used).
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TableScanPlan {
    /// Collection name.
    pub collection: String,
}

/// Property index lookup plan (O(1) lookup).
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct IndexLookupPlan {
    /// Label being queried.
    pub label: String,
    /// Property name with index.
    pub property: String,
    /// Value being looked up (as string representation).
    pub value: String,
}

/// MATCH traversal plan (EPIC-046 US-004).
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct MatchTraversalPlan {
    /// Execution strategy chosen by planner.
    pub strategy: String,
    /// Start node labels.
    pub start_labels: Vec<String>,
    /// Maximum traversal depth.
    pub max_depth: u32,
    /// Number of relationships in pattern.
    pub relationship_count: usize,
    /// Has similarity condition.
    pub has_similarity: bool,
    /// Similarity threshold (if any).
    pub similarity_threshold: Option<f32>,
}

/// NEAR_FUSED multi-vector fused search plan (VP-012, Phase 7).
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct FusedSearchPlan {
    /// Collection name.
    pub collection: String,
    /// Number of query vectors.
    pub vector_count: usize,
    /// Fusion strategy name (e.g., "RRF", "Average", "Weighted").
    pub fusion_strategy: String,
    /// Number of candidates to retrieve per vector.
    pub candidates: u32,
}

/// Cross-store combined V+G search plan (VP-010, Phase 7).
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CrossStoreSearchPlan {
    /// Collection name.
    pub collection: String,
    /// Execution strategy chosen by QueryPlanner.
    pub strategy: String,
    /// Over-fetch factor for filtered queries.
    pub over_fetch_factor: f64,
    /// Estimated cost in milliseconds.
    pub estimated_cost_ms: f64,
    /// Whether metadata filter is applied.
    pub has_metadata_filter: bool,
}

/// EXPLAIN output with optional ANALYZE stats (EPIC-046 US-004).
#[allow(dead_code)] // Used by API consumers
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExplainOutput {
    /// The query plan.
    pub plan: QueryPlan,
    /// Actual execution statistics (only with ANALYZE).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub actual_stats: Option<ActualStats>,
}

/// Actual execution statistics for EXPLAIN ANALYZE.
#[allow(dead_code)] // Used by API consumers
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActualStats {
    /// Actual number of rows returned.
    pub actual_rows: u64,
    /// Actual execution time in milliseconds.
    pub actual_time_ms: f64,
    /// Number of loop iterations.
    pub loops: u64,
    /// Number of nodes visited (for graph traversal).
    pub nodes_visited: u64,
    /// Number of edges traversed.
    pub edges_traversed: u64,
}

/// Type of index used in the query.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum IndexType {
    /// HNSW index for vector search.
    Hnsw,
    /// Flat index (brute force).
    Flat,
    /// Binary quantization index.
    BinaryQuantization,
    /// Property index for equality lookups.
    Property,
}

/// Strategy for applying filters.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
pub enum FilterStrategy {
    /// No filter.
    #[default]
    None,
    /// Pre-filtering: filter before vector search (high selectivity).
    PreFilter,
    /// Post-filtering: filter after vector search (low selectivity).
    PostFilter,
}

impl QueryPlan {
    /// Creates a new query plan from a SELECT statement.
    #[must_use]
    #[allow(clippy::too_many_lines)]
    pub fn from_select(stmt: &SelectStatement) -> Self {
        let mut nodes = Vec::new();
        let mut has_vector_search = false;
        let mut has_fused_search = false;
        let mut fused_info: Option<(usize, String)> = None;
        let mut filter_conditions = Vec::new();
        let mut filter_strategy = FilterStrategy::None;
        let mut index_used = None;

        // Analyze WHERE clause
        if let Some(ref condition) = stmt.where_clause {
            Self::analyze_condition(condition, &mut has_vector_search, &mut filter_conditions);
            // VP-012: detect NEAR_FUSED specifically
            if let Some(info) = Self::extract_fused_info(condition) {
                has_fused_search = true;
                fused_info = Some(info);
            }
        }

        // Build plan nodes
        if has_fused_search {
            // VP-012: NEAR_FUSED generates FusedSearch node
            index_used = Some(IndexType::Hnsw);
            let candidates = u32::try_from(stmt.limit.unwrap_or(50)).unwrap_or(u32::MAX);
            let (vector_count, fusion_strategy) = fused_info.unwrap_or((2, "RRF".to_string()));
            nodes.push(PlanNode::FusedSearch(FusedSearchPlan {
                collection: stmt.from.clone(),
                vector_count,
                fusion_strategy,
                candidates,
            }));
        } else if has_vector_search {
            index_used = Some(IndexType::Hnsw);
            let candidates = u32::try_from(stmt.limit.unwrap_or(50)).unwrap_or(u32::MAX);
            nodes.push(PlanNode::VectorSearch(VectorSearchPlan {
                collection: stmt.from.clone(),
                ef_search: 100, // Default HNSW parameter
                candidates,
            }));
        } else {
            nodes.push(PlanNode::TableScan(TableScanPlan {
                collection: stmt.from.clone(),
            }));
        }

        // Add filter if needed
        if !filter_conditions.is_empty() {
            let selectivity = Self::estimate_selectivity(&filter_conditions);
            filter_strategy = if selectivity > 0.1 {
                FilterStrategy::PostFilter
            } else {
                FilterStrategy::PreFilter
            };

            nodes.push(PlanNode::Filter(FilterPlan {
                conditions: filter_conditions.join(" AND "),
                selectivity,
            }));
        }

        // Add offset before limit
        if let Some(offset) = stmt.offset {
            nodes.push(PlanNode::Offset(OffsetPlan { count: offset }));
        }

        // Add limit
        if let Some(limit) = stmt.limit {
            nodes.push(PlanNode::Limit(LimitPlan { count: limit }));
        }

        let root = if nodes.len() == 1 {
            nodes.swap_remove(0)
        } else {
            PlanNode::Sequence(nodes)
        };

        let estimated_cost_ms = Self::estimate_cost(&root, has_vector_search);

        Self {
            root,
            estimated_cost_ms,
            index_used,
            filter_strategy,
        }
    }

    /// Analyzes a condition to extract vector search and filter info.
    fn analyze_condition(
        condition: &Condition,
        has_vector_search: &mut bool,
        filter_conditions: &mut Vec<String>,
    ) {
        match condition {
            Condition::VectorSearch(_)
            | Condition::VectorFusedSearch(_)
            | Condition::Similarity(_) => {
                *has_vector_search = true;
            }
            Condition::Comparison(cmp) => {
                filter_conditions.push(format!("{} {} ?", cmp.column, cmp.operator.as_str()));
            }
            Condition::In(inc) => {
                filter_conditions.push(format!("{} IN (...)", inc.column));
            }
            Condition::Between(btw) => {
                filter_conditions.push(format!("{} BETWEEN ? AND ?", btw.column));
            }
            Condition::Like(lk) => {
                filter_conditions.push(format!("{} LIKE ?", lk.column));
            }
            Condition::IsNull(isn) => {
                let op = if isn.is_null {
                    "IS NULL"
                } else {
                    "IS NOT NULL"
                };
                filter_conditions.push(format!("{} {op}", isn.column));
            }
            Condition::Match(m) => {
                filter_conditions.push(format!("{} MATCH ?", m.column));
            }
            Condition::And(left, right) | Condition::Or(left, right) => {
                Self::analyze_condition(left, has_vector_search, filter_conditions);
                Self::analyze_condition(right, has_vector_search, filter_conditions);
            }
            Condition::Not(inner) | Condition::Group(inner) => {
                Self::analyze_condition(inner, has_vector_search, filter_conditions);
            }
        }
    }

    /// Estimates selectivity (placeholder - would need statistics in production).
    pub(crate) fn estimate_selectivity(conditions: &[String]) -> f64 {
        // Heuristic: more conditions = lower selectivity
        let base = 0.5_f64;
        base.powi(i32::try_from(conditions.len()).unwrap_or(i32::MAX))
    }

    /// Estimates execution cost in milliseconds.
    fn estimate_cost(root: &PlanNode, has_vector_search: bool) -> f64 {
        let base_cost = if has_vector_search { 0.05 } else { 1.0 };

        match root {
            PlanNode::Sequence(nodes) => nodes
                .iter()
                .fold(base_cost, |acc, node| acc + Self::node_cost(node)),
            _ => base_cost + Self::node_cost(root),
        }
    }

    pub(crate) fn node_cost(node: &PlanNode) -> f64 {
        match node {
            PlanNode::VectorSearch(_) => 0.05,
            PlanNode::Filter(f) => 0.01 * (1.0 - f.selectivity),
            PlanNode::Limit(_) | PlanNode::Offset(_) => 0.001,
            PlanNode::TableScan(_) => 1.0,
            PlanNode::IndexLookup(_) => 0.0001, // O(1) lookup is very fast
            PlanNode::Sequence(nodes) => nodes.iter().map(Self::node_cost).sum(),
            PlanNode::MatchTraversal(mt) => {
                // Cost depends on depth and strategy
                let base = 0.1;
                let depth_factor = f64::from(mt.max_depth) * 0.05;
                let similarity_factor = if mt.has_similarity { 0.05 } else { 0.0 };
                base + depth_factor + similarity_factor
            }
            PlanNode::FusedSearch(fs) => {
                // Cost scales with number of vectors
                // SAFETY: vector_count is small (typically 2-10), no precision loss
                #[allow(clippy::cast_precision_loss)]
                let cost = 0.05 * fs.vector_count as f64;
                cost
            }
            PlanNode::CrossStoreSearch(_) => {
                // Cross-store queries are more expensive
                0.2
            }
        }
    }

    /// Extracts NEAR_FUSED info: (vector_count, fusion_strategy_name).
    fn extract_fused_info(condition: &Condition) -> Option<(usize, String)> {
        match condition {
            Condition::VectorFusedSearch(vfs) => {
                let strategy_name = vfs.fusion.strategy.to_uppercase();
                let strategy_name = if strategy_name == "RRF" {
                    "RRF".to_string()
                } else {
                    // Capitalize first letter
                    let mut s = vfs.fusion.strategy.clone();
                    if let Some(c) = s.get_mut(0..1) {
                        c.make_ascii_uppercase();
                    }
                    s
                };
                Some((vfs.vectors.len(), strategy_name))
            }
            Condition::And(left, right) | Condition::Or(left, right) => {
                Self::extract_fused_info(left).or_else(|| Self::extract_fused_info(right))
            }
            Condition::Not(inner) | Condition::Group(inner) => Self::extract_fused_info(inner),
            _ => None,
        }
    }

    /// Creates a `QueryPlan` for a combined SELECT + MATCH query (VP-010).
    #[must_use]
    pub fn from_combined(
        stmt: &SelectStatement,
        _match_clause: &MatchClause,
        has_order_by_similarity: bool,
        has_metadata_filter: bool,
    ) -> Self {
        let strategy = if has_order_by_similarity {
            "VectorFirst"
        } else {
            "Parallel"
        };

        let over_fetch_factor = if has_metadata_filter { 3.0 } else { 2.0 };

        let root = PlanNode::CrossStoreSearch(CrossStoreSearchPlan {
            collection: stmt.from.clone(),
            strategy: strategy.to_string(),
            over_fetch_factor,
            estimated_cost_ms: 0.2,
            has_metadata_filter,
        });

        let estimated_cost_ms = Self::node_cost(&root);

        Self {
            root,
            estimated_cost_ms,
            index_used: Some(IndexType::Hnsw),
            filter_strategy: if has_metadata_filter {
                FilterStrategy::PostFilter
            } else {
                FilterStrategy::None
            },
        }
    }

    /// Creates a new query plan from a MATCH clause (EPIC-046 US-004).
    #[must_use]
    pub fn from_match(match_clause: &MatchClause, stats: &CollectionStats) -> Self {
        let strategy = MatchQueryPlanner::plan(match_clause, stats);
        let strategy_explanation = MatchQueryPlanner::explain(&strategy);

        // Extract info from strategy
        let (start_labels, max_depth, has_similarity, similarity_threshold) = match &strategy {
            MatchExecutionStrategy::GraphFirst {
                start_labels,
                max_depth,
            } => (start_labels.clone(), *max_depth, false, None),
            MatchExecutionStrategy::VectorFirst { threshold, .. } => {
                (Vec::new(), 1, true, Some(*threshold))
            }
            MatchExecutionStrategy::Parallel {
                graph_hint,
                vector_hint,
            } => {
                let (labels, depth) = match graph_hint.as_ref() {
                    MatchExecutionStrategy::GraphFirst {
                        start_labels,
                        max_depth,
                    } => (start_labels.clone(), *max_depth),
                    _ => (Vec::new(), 1),
                };
                let threshold = match vector_hint.as_ref() {
                    MatchExecutionStrategy::VectorFirst { threshold, .. } => Some(*threshold),
                    _ => None,
                };
                (labels, depth, true, threshold)
            }
        };

        // Count relationships
        let relationship_count = match_clause
            .patterns
            .first()
            .map_or(0, |p| p.relationships.len());

        let mut nodes = Vec::new();

        // Main MATCH traversal node
        nodes.push(PlanNode::MatchTraversal(MatchTraversalPlan {
            strategy: strategy_explanation,
            start_labels,
            max_depth,
            relationship_count,
            has_similarity,
            similarity_threshold,
        }));

        // Add limit if present
        if let Some(limit) = match_clause.return_clause.limit {
            nodes.push(PlanNode::Limit(LimitPlan { count: limit }));
        }

        let root = if nodes.len() == 1 {
            nodes.swap_remove(0)
        } else {
            PlanNode::Sequence(nodes)
        };

        let estimated_cost_ms = Self::estimate_cost(&root, has_similarity);
        let index_used = if has_similarity {
            Some(IndexType::Hnsw)
        } else {
            None
        };

        Self {
            root,
            estimated_cost_ms,
            index_used,
            filter_strategy: FilterStrategy::None,
        }
    }
}

// Rendering, formatting, Display impl, and as_str() methods moved to explain/formatter.rs
// Tests in explain_tests.rs per project rules (tests in separate files)
