---
phase: 7
plan: 2
name: Full Zero-Dispatch DistanceEngine for HNSW
wave: 1
depends_on: ["07-01"]
autonomous: true
---

# Phase 7 Plan 2: Full Zero-Dispatch DistanceEngine for HNSW

## Objective

Eliminate ALL per-call dispatch overhead in HNSW distance calculations. Currently,
every `self.distance.distance(a, b)` call in the search hot loop goes through:
1. `match self.metric` (5-way branch)
2. `match simd_level()` (4-way branch via OnceLock)
3. `match a.len() >= threshold` (2-4 dimension checks)

This plan resolves everything at construction time for ALL 5 metrics — no second-class
citizens. Hamming and Jaccard get the same cached treatment as Cosine/Euclidean/DotProduct.

## Context

**Requirements addressed:** PERF-04
**Phase goal contribution:** Eliminate ~8 branches per distance call in HNSW hot loop

### Current Architecture (3 levels of dispatch per call)

```
SimdDistance::distance(a, b)
  ├─ match self.metric               ← 5-way branch (Cosine/Euclidean/Dot/Hamming/Jaccard)
  └─ cosine_similarity_native(a, b)
       ├─ match simd_level()          ← OnceLock atomic + 4-way branch
       └─ match a.len() >= 1024      ← 2-4 dimension threshold checks
```

### Target Architecture (single metric branch + direct fn pointer)

```
CachedSimdDistance::distance(a, b)
  ├─ match self.metric               ← 1 predictable branch (constant per HNSW index)
  └─ self.engine.cosine_similarity()
       └─ (self.cosine_fn)(a, b)     ← Direct fn pointer, ZERO branches
```

The metric branch stays because the transforms (`1.0 - cosine`, `-dot`) can't be baked
into a single fn pointer without closures (which can't be coerced to `fn`). This branch
is perfectly predicted by the CPU since a given HNSW index always uses the same metric.

### Key Insight: Extend simd_native::DistanceEngine

The existing `DistanceEngine` struct (from Phase 5) only caches dot_product, squared_l2,
and cosine fn pointers. We MUST extend it with hamming and jaccard fn pointers so all
5 metrics get cached dispatch. No second-class citizens.

## Tasks

### Task 1: Extend `simd_native::DistanceEngine` with hamming and jaccard

**Files:** `crates/velesdb-core/src/simd_native/dispatch.rs`

**Action:**
Add two new fields to `DistanceEngine`:

```rust
pub struct DistanceEngine {
    dot_product_fn: fn(&[f32], &[f32]) -> f32,
    squared_l2_fn: fn(&[f32], &[f32]) -> f32,
    cosine_fn: fn(&[f32], &[f32]) -> f32,
    hamming_fn: fn(&[f32], &[f32]) -> f32,    // NEW
    jaccard_fn: fn(&[f32], &[f32]) -> f32,    // NEW
    dimension: usize,
}
```

Add public methods:
```rust
/// Computes Hamming distance using the pre-resolved SIMD kernel.
#[inline(always)]
#[must_use]
pub fn hamming(&self, a: &[f32], b: &[f32]) -> f32 {
    (self.hamming_fn)(a, b)
}

/// Computes Jaccard similarity using the pre-resolved SIMD kernel.
#[inline(always)]
#[must_use]
pub fn jaccard(&self, a: &[f32], b: &[f32]) -> f32 {
    (self.jaccard_fn)(a, b)
}
```

Add resolve functions:
```rust
fn resolve_hamming(level: SimdLevel, dim: usize) -> fn(&[f32], &[f32]) -> f32 {
    match level {
        #[cfg(target_arch = "x86_64")]
        SimdLevel::Avx512 if dim >= 16 => |a, b| unsafe { super::hamming_avx512(a, b) },
        #[cfg(target_arch = "x86_64")]
        SimdLevel::Avx2 if dim >= 8 => |a, b| unsafe { super::hamming_avx2(a, b) },
        _ => scalar::hamming_scalar,
    }
}

fn resolve_jaccard(level: SimdLevel, dim: usize) -> fn(&[f32], &[f32]) -> f32 {
    match level {
        #[cfg(target_arch = "x86_64")]
        SimdLevel::Avx512 if dim >= 16 => |a, b| unsafe { super::jaccard_avx512(a, b) },
        #[cfg(target_arch = "x86_64")]
        SimdLevel::Avx2 if dim >= 8 => |a, b| unsafe { super::jaccard_avx2(a, b) },
        _ => scalar::jaccard_scalar,
    }
}
```

Update `DistanceEngine::new()` to populate the new fields.

**Verify:**
```powershell
cargo check --package velesdb-core
cargo test --package velesdb-core distance_engine -- --nocapture
```

**Done when:**
- `DistanceEngine` has 5 fn pointer fields (dot, l2, cosine, hamming, jaccard)
- Existing 16 distance_engine tests still pass
- New `hamming()` and `jaccard()` methods work

---

### Task 2: Add unit tests for extended DistanceEngine

**Files:** `crates/velesdb-core/src/simd_native/distance_engine_tests.rs`

**Action:**
Add tests verifying the new cached hamming/jaccard methods match `*_native()`:

```rust
#[test]
fn test_engine_hamming_matches_native() {
    for dim in [8, 16, 32, 64, 128, 256, 512, 768, 1024, 1536] {
        let engine = DistanceEngine::new(dim);
        let a: Vec<f32> = (0..dim).map(|i| if i % 3 == 0 { 1.0 } else { 0.0 }).collect();
        let b: Vec<f32> = (0..dim).map(|i| if i % 2 == 0 { 1.0 } else { 0.0 }).collect();
        let cached = engine.hamming(&a, &b);
        let native = hamming_distance_native(&a, &b);
        assert_eq!(cached, native, "hamming mismatch at dim={dim}");
    }
}

#[test]
fn test_engine_jaccard_matches_native() {
    // Similar pattern with set-like vectors
}
```

**Verify:**
```powershell
cargo test --package velesdb-core distance_engine -- --nocapture
```

**Done when:**
- Tests verify hamming/jaccard cached dispatch matches native dispatch across all dimensions

---

### Task 3: Create `CachedSimdDistance` in HNSW distance module

**Files:** `crates/velesdb-core/src/index/hnsw/native/distance.rs`

**Action:**
Add `CachedSimdDistance` that wraps `simd_native::DistanceEngine` and implements the
HNSW `DistanceEngine` trait:

```rust
/// SIMD distance with fully cached kernel resolution for HNSW hot loops.
///
/// All 5 distance metrics use pre-resolved fn pointers via `simd_native::DistanceEngine`.
/// The only per-call branch is `match self.metric` for the distance-to-similarity
/// transform (1-cosine, -dot), which is perfectly predicted by the branch predictor
/// since a given HNSW index always uses the same metric.
pub struct CachedSimdDistance {
    metric: DistanceMetric,
    engine: crate::simd_native::DistanceEngine,
}

impl CachedSimdDistance {
    /// Creates a cached SIMD distance engine optimized for the given metric and dimension.
    #[must_use]
    pub fn new(metric: DistanceMetric, dimension: usize) -> Self {
        Self {
            metric,
            engine: crate::simd_native::DistanceEngine::new(dimension),
        }
    }
}

impl DistanceEngine for CachedSimdDistance {
    #[inline(always)]
    fn distance(&self, a: &[f32], b: &[f32]) -> f32 {
        match self.metric {
            DistanceMetric::Cosine => 1.0 - self.engine.cosine_similarity(a, b),
            DistanceMetric::Euclidean => self.engine.euclidean(a, b),
            DistanceMetric::DotProduct => -self.engine.dot_product(a, b),
            DistanceMetric::Hamming => self.engine.hamming(a, b),
            DistanceMetric::Jaccard => 1.0 - self.engine.jaccard(a, b),
        }
    }

    fn batch_distance(&self, query: &[f32], candidates: &[&[f32]]) -> Vec<f32> {
        let prefetch_distance = crate::simd_native::calculate_prefetch_distance(query.len());
        let mut results = Vec::with_capacity(candidates.len());
        for (i, candidate) in candidates.iter().enumerate() {
            if i + prefetch_distance < candidates.len() {
                crate::simd_native::prefetch_vector(candidates[i + prefetch_distance]);
            }
            results.push(self.distance(query, candidate));
        }
        results
    }

    fn metric(&self) -> DistanceMetric {
        self.metric
    }
}
```

Re-export in `mod.rs`: `pub use distance::CachedSimdDistance;`

**Verify:**
```powershell
cargo check --package velesdb-core
```

**Done when:**
- `CachedSimdDistance` compiles and implements `DistanceEngine` trait
- All 5 metrics use cached engine methods (no fallback to `*_native()`)

---

### Task 4: Add unit tests for `CachedSimdDistance`

**Files:** `crates/velesdb-core/src/index/hnsw/native/distance_tests.rs`

**Action:**
Add tests verifying `CachedSimdDistance` produces identical results to `SimdDistance`:

1. `test_cached_vs_simd_cosine_768d` — exact match
2. `test_cached_vs_simd_euclidean_128d` — exact match
3. `test_cached_vs_simd_dot_product_1536d` — exact match
4. `test_cached_vs_simd_hamming_64d` — exact match
5. `test_cached_vs_simd_jaccard_256d` — exact match
6. `test_cached_batch_distance_matches_single` — batch vs loop

Each test creates both `SimdDistance::new(metric)` and `CachedSimdDistance::new(metric, dim)`,
computes distance on identical vectors, and asserts **exact bit-for-bit equality**.

**Verify:**
```powershell
cargo test --package velesdb-core cached_vs_simd -- --nocapture
```

**Done when:**
- 6 tests pass with exact equality

---

### Task 5: Wire `CachedSimdDistance` into `NativeHnswBackend`

**Files:** `crates/velesdb-core/src/index/hnsw/native/backend_adapter.rs`

**Action:**
Find where `NativeHnsw<SimdDistance>` is constructed. Change to `CachedSimdDistance`
where the dimension is known at construction time.

If dimension is passed at construction (typical — it comes from collection config),
use `CachedSimdDistance::new(metric, dimension)`.

Update the type alias or generic parameter throughout `backend_adapter.rs`.

**Verify:**
```powershell
cargo check --package velesdb-core
cargo test --package velesdb-core hnsw -- --nocapture 2>&1 | Select-String "test result"
```

**Done when:**
- `NativeHnswBackend` uses `CachedSimdDistance`
- All existing HNSW tests pass unchanged

---

### Task 6: Benchmark and document improvement

**Files:** None (verification only)

**Action:**
Run HNSW benchmarks or create ad-hoc timing test:
- Insert 10,000 random 768d vectors into `NativeHnsw<CachedSimdDistance>`
- Search 100 queries with ef=128, k=10
- Compare total search time vs `NativeHnsw<SimdDistance>`

Document results in commit message.

**Verify:**
```powershell
cargo bench --package velesdb-core --bench hnsw_benchmark 2>&1 | Select-String "time:"
```

**Done when:**
- Performance measured, no regression
- Improvement documented

---

## Verification

After all tasks complete:

```powershell
cargo test --package velesdb-core -- 2>&1 | Select-String "test result"
cargo clippy --package velesdb-core -- -D warnings
cargo test --package velesdb-core --test simd_property_tests
```

## Success Criteria

- [ ] `simd_native::DistanceEngine` extended with hamming_fn and jaccard_fn fields
- [ ] All 5 metrics use cached fn pointers (no second-class Hamming/Jaccard)
- [ ] `CachedSimdDistance` created with `DistanceEngine` trait impl
- [ ] 8+ unit tests verify parity (2 engine + 6 cached)
- [ ] `NativeHnswBackend` wired to use `CachedSimdDistance`
- [ ] All existing tests pass (no regressions)
- [ ] `cargo clippy -- -D warnings` clean

## Output

**Files modified:**
- `crates/velesdb-core/src/simd_native/dispatch.rs` — hamming_fn, jaccard_fn fields + resolve fns
- `crates/velesdb-core/src/simd_native/distance_engine_tests.rs` — 2 new tests
- `crates/velesdb-core/src/index/hnsw/native/distance.rs` — `CachedSimdDistance` struct
- `crates/velesdb-core/src/index/hnsw/native/mod.rs` — Re-export `CachedSimdDistance`
- `crates/velesdb-core/src/index/hnsw/native/distance_tests.rs` — 6 new tests
- `crates/velesdb-core/src/index/hnsw/native/backend_adapter.rs` — Use `CachedSimdDistance`
