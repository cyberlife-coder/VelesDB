---
phase: 4
plan: 4
name: Simple MATCH Business Scenarios
wave: 2
depends_on: [04-01]
autonomous: true
parallel_safe: true
---

# Phase 4 Plan 04: Simple MATCH Business Scenarios

## Objective

Implement E2E tests for Business Scenario 1 (E-commerce Product Discovery) and Business Scenario 4 (AI Agent Memory). These use single-hop MATCH patterns with similarity thresholds, column filters, temporal conditions, and ORDER BY.

## Context

**Requirements addressed:** VP-007
**Phase goal contribution:** Validates that the two simpler MATCH business scenarios from the README work end-to-end. These combine vector similarity with graph traversal and structured data filtering in single-hop patterns.

## Tasks

### Task 1: Implement Business Scenario 1 — E-commerce Product Discovery

**Files:** `tests/readme_scenarios/match_simple.rs`

**Action:**
Test the README query pattern:
```sql
MATCH (product:Product)-[:SUPPLIED_BY]->(supplier:Supplier)
WHERE 
  similarity(product.image_embedding, $uploaded_photo) > 0.7
  AND supplier.trust_score > 4.5
  AND (SELECT price FROM inventory WHERE sku = product.sku) < 500
ORDER BY similarity() DESC
LIMIT 12
```

**Simplified test** (subquery tested separately in Plan 04-06):
```sql
MATCH (product:Product)-[:SUPPLIED_BY]->(supplier:Supplier)
WHERE 
  similarity(product.image_embedding, $uploaded_photo) > 0.7
  AND supplier.trust_score > 4.5
ORDER BY similarity() DESC
LIMIT 12
```

Implementation:
1. Create collection (dim=4, cosine) — small dim for fast tests
2. Insert 6+ Product nodes with `_labels: ["Product"]`, `name`, `price`, `image_embedding` (as vector), `sku`
3. Insert 3+ Supplier nodes with `_labels: ["Supplier"]`, `name`, `trust_score` (mix of high/low)
4. Add `SUPPLIED_BY` edges from products to suppliers
5. Build `MatchClause` with:
   - Pattern: `(product:Product)-[:SUPPLIED_BY]->(supplier:Supplier)`
   - WHERE: similarity condition + `supplier.trust_score > 4.5` (via binding-aware evaluation)
   - RETURN: `product.name, supplier.name`
   - ORDER BY similarity() DESC, LIMIT 12
6. Execute and assert:
   - Only products from high-trust suppliers returned
   - Similarity threshold filters low-similarity products
   - Results contain projected properties from both product and supplier
   - Results ordered by similarity DESC

**Verify:**
```powershell
cargo test --test readme_scenarios match_simple::test_bs1_ecommerce_discovery -- --nocapture
```

**Done when:**
- MATCH traversal follows SUPPLIED_BY edges correctly
- Similarity threshold filters products
- Supplier trust_score filter works via binding-aware WHERE
- Results contain cross-node projected properties

---

### Task 2: Implement Business Scenario 4 — AI Agent Memory

**Files:** `tests/readme_scenarios/match_simple.rs`

**Action:**
Test the README query pattern:
```sql
MATCH (user:User)-[:HAD_CONVERSATION]->(conv:Conversation)
      -[:CONTAINS]->(message:Message)
WHERE 
  similarity(message.embedding, $current_query) > 0.7
  AND conv.timestamp > NOW() - INTERVAL '7 days'
ORDER BY conv.timestamp DESC, similarity() DESC
LIMIT 10
```

**Simplified test** (temporal as fixed epoch, subquery excluded):
Build as multi-hop MATCH (2 hops: User→Conversation→Message).

Implementation:
1. Create collection (dim=4, cosine)
2. Insert User nodes with `_labels: ["User"]`, `name`
3. Insert Conversation nodes with `_labels: ["Conversation"]`, `timestamp` (epoch integers, mix of recent/old)
4. Insert Message nodes with `_labels: ["Message"]`, `content`, vectors for similarity
5. Add edges: `HAD_CONVERSATION` (User→Conv), `CONTAINS` (Conv→Message)
6. Build `MatchClause` with:
   - Pattern: `(user:User)-[:HAD_CONVERSATION]->(conv:Conversation)-[:CONTAINS]->(message:Message)`
   - WHERE: `conv.timestamp > {fixed_epoch}` (binding-aware, alias-qualified)
   - RETURN: `user.name, conv.timestamp, message.content`
   - LIMIT 10
7. Execute and assert:
   - Multi-hop traversal reaches Message nodes through Conversation
   - Only recent conversations included (timestamp filter on intermediate node)
   - Bindings contain user, conv, message aliases
   - Projected properties from all 3 nodes returned

Note: ORDER BY conv.timestamp DESC requires VP-006 (property ORDER BY in MATCH). If not yet supported, test without ORDER BY and document the limitation.

**Verify:**
```powershell
cargo test --test readme_scenarios match_simple::test_bs4_agent_memory -- --nocapture
```

**Done when:**
- Multi-hop MATCH (2 hops) works: User→Conversation→Message
- Binding-aware WHERE filters on intermediate node (conv.timestamp)
- All 3 node aliases populated in bindings
- Cross-node property projection works

---

## Verification

After all tasks complete:

```powershell
cargo test --test readme_scenarios match_simple -- --nocapture
cargo clippy --test readme_scenarios -- -D warnings
```

## Success Criteria

- [ ] BS1 E-commerce: single-hop MATCH + similarity + supplier filter works
- [ ] BS4 Agent Memory: multi-hop MATCH (2 hops) + temporal filter on intermediate node
- [ ] Binding-aware WHERE correctly resolves alias-qualified columns (e.g., `supplier.trust_score`)
- [ ] Cross-node property projection in RETURN clause works
- [ ] Tests use realistic data structures matching README descriptions

## Parallel Safety

**Exclusive write files:** `tests/readme_scenarios/match_simple.rs`
**Shared read files:** `tests/readme_scenarios/helpers.rs` (read), `crates/velesdb-core/src/**` (read)
**Conflicts with:** none (unique write file)

## Output

**Files modified:**
- `tests/readme_scenarios/match_simple.rs` — Replaces stub with 2 MATCH business scenario tests
