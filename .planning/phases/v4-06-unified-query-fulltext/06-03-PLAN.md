# Plan 06-03: Cross-Store Query Planner Integration (VP-010)

## Objective

Integrate the existing `QueryPlanner` and `hybrid.rs` fusion infrastructure into `execute_query()`, enabling combined Vector + Graph MATCH + Column filter queries with cost-based strategy selection.

**Estimate:** 6-8h
**Wave:** 2 (depends on 06-01 and 06-02)

---

## Context

### Current State
- `QueryPlanner` in `velesql/planner.rs` provides VectorFirst/GraphFirst/Parallel strategies
- `MatchQueryPlanner` in `match_planner.rs` provides MATCH-specific planning
- `hybrid.rs` has `fuse_rrf()`, `fuse_weighted()`, `fuse_maximum()`, `intersect_results()` — all `#[allow(dead_code)]`
- `execute_query()` handles NEAR or MATCH independently but not combined in same WHERE
- Graph MATCH execution exists in `match_exec/` module

### Target State
- `QueryPlanner::choose_hybrid_strategy()` called during execute_query() for hybrid queries
- Combined queries (NEAR + Graph MATCH) execute with strategy-based optimization
- `hybrid.rs` functions used for result fusion (dead_code removed)
- Cross-store results properly merged on unified ID space

---

## Tasks

### Task 1: TDD — Write cross-store query tests

**Files:** `crates/velesdb-core/src/collection/search/query/cross_store_tests.rs`

**Action:**
1. Create test file with tests for:
   - `test_planner_selects_vector_first_for_dense_graph` — verify strategy selection
   - `test_planner_selects_graph_first_for_selective_labels` — verify strategy
   - `test_cross_store_near_with_graph_match` — NEAR + MATCH (a)-[:REL]->(b)
   - `test_cross_store_rrf_fusion` — verify RRF fusion of vector + graph results
   - `test_cross_store_intersect_results` — AND semantics (both must match)
   - `test_cross_store_with_column_filter` — three-way: V + G + C
   - `test_cross_store_order_by_similarity` — ORDER BY similarity() in cross-store
   - `test_planner_stats_update` — verify latency stats accumulate
2. Register test module in `mod.rs`

**Verify:** `cargo test cross_store_tests -- --no-run`

**Done:** Test file created, module registered

### Task 2: Wire QueryPlanner into execute_query()

**Files:** `crates/velesdb-core/src/collection/search/query/mod.rs`

**Action:**
1. Add `QueryPlanner` instance to Collection (or create on-demand)
2. In `execute_query()`, when both vector search and graph MATCH are detected:
   - Call `planner.choose_hybrid_strategy()` with query characteristics
   - Use `HybridExecutionPlan` to determine over-fetch factor and strategy
3. Add a new dispatch path for combined queries:
   ```
   // NEAR + Graph MATCH detected
   (Some(vector), graph_match=true, filter) => {
       let plan = planner.choose_hybrid_strategy(...);
       match plan.strategy {
           VectorFirst => vector_search → graph_validate → filter,
           GraphFirst => graph_traverse → vector_score → filter,
           Parallel => parallel_execute → fuse → filter,
       }
   }
   ```
4. Track query latencies for adaptive planning via `planner.stats()`

**Verify:** `cargo check --package velesdb-core`

**Done:** Planner wired, compiles clean

### Task 3: Implement VectorFirst cross-store execution

**Files:** `crates/velesdb-core/src/collection/search/query/cross_store_exec.rs` (new module)

**Action:**
1. Create `cross_store_exec.rs` with `execute_vector_first_cross_store()`:
   - Execute vector NEAR search with over-fetch
   - For each candidate, validate against graph MATCH pattern
   - Apply column metadata filters
   - Return merged results sorted by vector score
2. Use existing `match_exec` infrastructure for graph validation
3. Use existing `filter::Filter` for column filtering
4. Keep module under 300 lines

**Verify:** `cargo test cross_store_tests::test_cross_store_near_with_graph_match`

**Done:** VectorFirst path works, test passes

### Task 4: Remove dead_code from hybrid.rs and wire fusion

**Files:** `crates/velesdb-core/src/velesql/hybrid.rs`

**Action:**
1. Remove `#![allow(dead_code)]` from hybrid.rs
2. Wire `fuse_rrf()` into cross-store execution for Parallel strategy
3. Wire `intersect_results()` for AND-semantics queries
4. Wire `normalize_scores()` for weighted fusion
5. Fix any resulting compilation issues from dead_code removal

**Verify:** `cargo check --package velesdb-core && cargo clippy -- -D warnings`

**Done:** hybrid.rs no longer has dead_code, functions actively used

### Task 5: Implement Parallel cross-store execution

**Files:** `crates/velesdb-core/src/collection/search/query/cross_store_exec.rs`

**Action:**
1. Add `execute_parallel_cross_store()`:
   - Execute vector search and graph traversal concurrently (rayon or sequential)
   - Convert both to `ScoredResult` format
   - Apply `fuse_rrf()` from hybrid.rs to combine
   - Apply post-fusion column filters
2. GraphFirst strategy: traverse first, then score vectors for candidates

**Verify:** `cargo test cross_store_tests`

**Done:** All cross-store tests pass GREEN

### Task 6: Extract dispatch logic from mod.rs to reduce complexity

**Files:** `crates/velesdb-core/src/collection/search/query/mod.rs`, new `dispatch.rs`

**Action:**
1. `execute_query()` is already 390 lines (project limit: 300 lines per module)
2. Extract the new cross-store + NEAR_FUSED dispatch branches into a `dispatch.rs` module:
   - `dispatch_fused_search()` — NEAR_FUSED path (from 06-01)
   - `dispatch_cross_store()` — NEAR + Graph MATCH path
   - `dispatch_hybrid_text()` — NEAR + BM25 MATCH path (from 06-02)
3. Keep `execute_query()` as the top-level orchestrator calling into dispatch functions
4. Ensure mod.rs stays under 300 lines after extraction

**Verify:** `wc -l mod.rs` < 300, `cargo check --package velesdb-core`

**Done:** mod.rs under 300 lines, dispatch logic in separate module

### Task 7: Add EXPLAIN support for new execution paths

**Files:** `crates/velesdb-core/src/velesql/explain.rs`

**Action:**
1. Add EXPLAIN output for NEAR_FUSED queries:
   - Show fusion strategy name, number of vectors, resolved params
2. Add EXPLAIN output for cross-store queries:
   - Show chosen strategy (VectorFirst/GraphFirst/Parallel)
   - Show over-fetch factor
   - Show estimated cost from QueryPlanner
3. Add test: `test_explain_near_fused_query`, `test_explain_cross_store_query`

**Verify:** `cargo test explain`

**Done:** EXPLAIN shows strategy details for all new query paths

### Task 8: Integration and quality gates

**Files:** Various

**Action:**
1. Verify no regressions on existing 3,222 tests
2. Verify execute_query() dispatches correctly for all combinations:
   - Pure NEAR → existing path (unchanged)
   - Pure MATCH (graph) → existing path (unchanged)
   - Pure MATCH (text) → existing path (unchanged)
   - NEAR + text MATCH → hybrid_search() (from 06-02)
   - NEAR + graph MATCH → new cross-store path
   - NEAR + graph MATCH + filter → new cross-store path
   - NEAR_FUSED → multi_query_search() (from 06-01)
3. Run clippy, fmt, deny

**Verify:** `cargo test --workspace && cargo clippy -- -D warnings && cargo fmt --all --check`

**Done:** All quality gates pass

---

## Future Optimizations (out of scope)

- **Trigram → BM25 pre-filter**: Wire trigram index as candidate pre-filter before BM25 scoring for LIKE acceleration. Currently BM25 and trigram are independent indexes. This is a perf optimization, not a correctness requirement.
- **Unify `FusionStrategyType` and `FusionConfig`**: The AST has two fusion hierarchies — `FusionStrategyType` (enum: Rrf, Weighted, Maximum — no Average) used by `FusionClause` for MATCH+NEAR hybrid, and `FusionConfig` (String-based — includes "average") used by `VectorFusedSearch` for NEAR_FUSED. Consider unifying into a single enum with all 4 strategies.

---

## Success Criteria

- [ ] QueryPlanner integrated into execute_query()
- [ ] Cross-store NEAR + Graph MATCH executes correctly
- [ ] VectorFirst, GraphFirst, Parallel strategies all work
- [ ] hybrid.rs functions no longer dead_code
- [ ] EXPLAIN shows strategy for new query paths
- [ ] mod.rs stays under 300 lines (dispatch extracted)
- [ ] 10+ new tests pass (including EXPLAIN tests)
- [ ] No regressions on existing 3,222 tests
- [ ] `cargo clippy -- -D warnings` clean
