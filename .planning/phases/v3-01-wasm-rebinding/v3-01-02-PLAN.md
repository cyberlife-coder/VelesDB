---
phase: v3-01
plan: 02
name: Core In-Memory API Surface for WASM
wave: 2
depends_on: [v3-01-01]
autonomous: true
parallel_safe: true
---

# Phase v3-01 Plan 02: Core In-Memory API Surface for WASM

## Objective

Expose in-memory-only graph types and utility functions from velesdb-core that work WITHOUT the `persistence` feature. This unblocks WASM rebinding (Plans 03-04) by making core's graph, filter conversion, and text search available to non-persistence consumers.

## Context

**Requirements addressed:** ECO-01, ECO-02, ECO-17
**Phase goal contribution:** Without this, WASM can't bind to core's graph or text search — it would keep reimplementing them.

**Key constraint:** `persistence` feature gates `collection`, `storage`, `index`, `agent`, `column_store`. Modules like `distance`, `filter`, `fusion`, `quantization`, `velesql` are already available without persistence.

**Gaps identified in Plan 01:**
1. `EdgeStore` / `GraphEdge` / `GraphNode` — behind `collection` (persistence-gated)
2. BFS/DFS traversal iterators — behind `collection` (persistence-gated)
3. Text search (substring/BM25) — behind `collection` (persistence-gated)
4. JSON-to-Condition filter conversion — not exposed as utility

## Tasks

### Task 1: Extract Graph Types to Non-Persistence Module

**Files:** `crates/velesdb-core/src/lib.rs`, `crates/velesdb-core/src/graph/mod.rs` (new), `crates/velesdb-core/src/graph/types.rs` (new), `crates/velesdb-core/src/graph/edge_store.rs` (new)

**Action:**
Create a new top-level `graph` module in velesdb-core that is NOT behind the `persistence` feature:

1. Create `src/graph/mod.rs` — module declarations and re-exports
2. Create `src/graph/types.rs` — `GraphNode`, `GraphEdge`, `NodeType`, `EdgeType`, `ValueType`, `GraphSchema` types. Copy from `collection/graph/` but without any persistence dependencies (no mmap, no file I/O)
3. Create `src/graph/edge_store.rs` — In-memory `EdgeStore` with:
   - `add_node()`, `get_node()`, `remove_node()`
   - `add_edge()`, `get_edge()`, `remove_edge()`
   - `get_outgoing()`, `get_incoming()`, `get_outgoing_by_label()`
   - Outgoing/incoming index (HashMap-based)
   - No file I/O, no mmap, no rayon

4. Update `lib.rs`:
   - Add `pub mod graph;` (NOT behind `#[cfg(feature = "persistence")]`)
   - Re-export key types: `pub use graph::{GraphNode, GraphEdge, EdgeStore as InMemoryEdgeStore};`
   - The existing `collection::graph` module continues to exist for persistence consumers

5. Ensure the existing `collection::graph::EdgeStore` can optionally wrap or extend the new in-memory `EdgeStore` (composition pattern) — this is a FUTURE concern, not blocking

**Important:** Do NOT break existing `collection::graph` API. The new `graph` module is additive.

**Verify:**
```powershell
# Build without persistence (WASM mode)
cargo check --package velesdb-core --no-default-features
# Build with persistence (normal mode)
cargo check --package velesdb-core
# All tests still pass
cargo test --workspace
```

**Done when:**
- `graph` module available without persistence feature
- `InMemoryEdgeStore` has add/get/remove for nodes and edges
- Outgoing/incoming index maintained
- Both `--no-default-features` and default builds pass

---

### Task 2: Extract BFS/DFS Traversal to Non-Persistence Module

**Files:** `crates/velesdb-core/src/graph/traversal.rs` (new), `crates/velesdb-core/src/graph/mod.rs`

**Action:**
Create `src/graph/traversal.rs` with generic BFS and DFS functions that work on any type implementing a `GraphTraversal` trait:

```rust
/// Trait for graph traversal — any graph store can implement this.
pub trait GraphTraversal {
    fn get_outgoing_edges(&self, node_id: u64) -> Vec<(u64, u64, String)>; // (edge_id, target, label)
}

/// BFS traversal result
pub struct TraversalStep {
    pub node_id: u64,
    pub depth: usize,
    pub path: Vec<u64>,
}

/// BFS from source node with max_depth and limit
pub fn bfs<G: GraphTraversal>(
    graph: &G,
    source_id: u64,
    max_depth: usize,
    limit: usize,
    rel_types: Option<&[String]>,
) -> Vec<TraversalStep> { ... }

/// DFS from source node with max_depth and limit
pub fn dfs<G: GraphTraversal>(
    graph: &G,
    source_id: u64,
    max_depth: usize,
    limit: usize,
    rel_types: Option<&[String]>,
) -> Vec<TraversalStep> { ... }
```

- Implement `GraphTraversal` for `InMemoryEdgeStore`
- The existing `collection::graph` BFS/DFS iterators can later be refactored to use this trait (not in this plan)

**Verify:**
```powershell
cargo check --package velesdb-core --no-default-features
cargo test --package velesdb-core -- graph::traversal
```

**Done when:**
- `bfs()` and `dfs()` functions available without persistence
- `InMemoryEdgeStore` implements `GraphTraversal`
- Unit tests for BFS/DFS with cycles, max_depth, limit, rel_type filtering

---

### Task 3: Expose JSON-to-Filter Conversion Utility

**Files:** `crates/velesdb-core/src/filter/json_filter.rs` (new), `crates/velesdb-core/src/filter/mod.rs`

**Action:**
Create a utility that converts a JSON filter object (the format WASM uses) to core's `Condition` type:

```rust
/// Converts a serde_json::Value filter to a core Condition.
///
/// JSON format: { "condition": { "type": "eq", "field": "x", "value": "y" } }
/// Supports: eq, neq, gt, gte, lt, lte, and, or, not
pub fn json_to_condition(filter: &serde_json::Value) -> Option<Condition> { ... }
```

This eliminates WASM's `filter.rs` reimplementation — WASM will call `json_to_condition()` then use core's `Filter::matches()`.

**Verify:**
```powershell
cargo check --package velesdb-core --no-default-features
cargo test --package velesdb-core -- filter::json_filter
```

**Done when:**
- `json_to_condition()` available without persistence
- Handles all operators: eq, neq, gt, gte, lt, lte, and, or, not
- Unit tests for each operator and nested conditions

---

## Verification

After all tasks complete:

```powershell
# Core builds without persistence
cargo check --package velesdb-core --no-default-features

# Core builds with persistence  
cargo check --package velesdb-core

# WASM package can see new types
cargo check --package velesdb-wasm

# All workspace tests pass
cargo test --workspace
```

## Success Criteria

- [ ] `graph` module exists at `velesdb-core/src/graph/` (NOT persistence-gated)
- [ ] `InMemoryEdgeStore` with full CRUD + indexes
- [ ] BFS/DFS traversal via `GraphTraversal` trait
- [ ] `json_to_condition()` converts JSON filter to core `Condition`
- [ ] `cargo check --no-default-features` passes for velesdb-core
- [ ] `cargo check --package velesdb-wasm` passes
- [ ] All existing tests pass (zero regressions)

## Parallel Safety

**Exclusive write files:**
- `crates/velesdb-core/src/graph/` (new directory)
- `crates/velesdb-core/src/graph/mod.rs` (new)
- `crates/velesdb-core/src/graph/types.rs` (new)
- `crates/velesdb-core/src/graph/edge_store.rs` (new)
- `crates/velesdb-core/src/graph/traversal.rs` (new)
- `crates/velesdb-core/src/filter/json_filter.rs` (new)

**Shared write files:**
- `crates/velesdb-core/src/lib.rs` (add `pub mod graph;`)
- `crates/velesdb-core/src/filter/mod.rs` (add `pub mod json_filter;`)

**Shared read files:** `crates/velesdb-core/src/filter/*.rs`, `crates/velesdb-core/src/collection/graph/*.rs`
**Conflicts with:** none (writes only to velesdb-core, no WASM changes)

## Output

**Files created:**
- `crates/velesdb-core/src/graph/mod.rs` — Module facade
- `crates/velesdb-core/src/graph/types.rs` — Graph types (no persistence)
- `crates/velesdb-core/src/graph/edge_store.rs` — In-memory EdgeStore
- `crates/velesdb-core/src/graph/traversal.rs` — BFS/DFS functions
- `crates/velesdb-core/src/filter/json_filter.rs` — JSON → Condition converter

**Files modified:**
- `crates/velesdb-core/src/lib.rs` — Add `pub mod graph;` + re-exports
- `crates/velesdb-core/src/filter/mod.rs` — Add `pub mod json_filter;`
