---
phase: v3-01
plan: 04
name: WASM GraphStore Rebinding
wave: 4
depends_on: [v3-01-02, v3-01-03]
autonomous: true
parallel_safe: false
---

# Phase v3-01 Plan 04: WASM GraphStore Rebinding

## Objective

Replace WASM's reimplemented GraphStore (BFS/DFS, node/edge management) with proper bindings to velesdb-core's new `graph` module (created in Plan 02). Delete ~1,100 lines of reimplemented graph code. Keep WASM-specific persistence (IndexedDB) and Web Worker modules as thin adapters.

## Context

**Requirements addressed:** ECO-02 (3 parallel BFS/DFS → use core's traversal)
**Phase goal contribution:** Eliminates the second major reimplementation. After this, graph operations in WASM produce identical results to core.

**Current state:**
- `graph.rs` (550L): Full `GraphStore` with own BFS/DFS, node/edge CRUD, indexing
- `graph_persistence.rs` (330L): IndexedDB persistence for GraphStore — WASM-specific, keep
- `graph_worker.rs` (250L): Web Worker wrapper for graph ops — WASM-specific, keep
- `graph_tests.rs` (280L): Tests for current GraphStore

**After Plan 02:** Core has `graph::InMemoryEdgeStore`, `graph::traversal::{bfs, dfs}`, `graph::types::{GraphNode, GraphEdge}`.

## Tasks

### Task 1: Replace GraphStore Internals with Core's InMemoryEdgeStore

**Files:** `crates/velesdb-wasm/src/graph.rs`, `crates/velesdb-wasm/src/lib.rs`

**Action:**
Replace `GraphStore`'s internal data structures with core's `InMemoryEdgeStore`:

```rust
// Before: Own HashMap-based storage
pub struct GraphStore {
    nodes: HashMap<u64, GraphNode>,
    edges: HashMap<u64, GraphEdge>,
    outgoing: HashMap<u64, Vec<u64>>,
    incoming: HashMap<u64, Vec<u64>>,
}

// After: Delegate to core
use velesdb_core::graph::InMemoryEdgeStore;

pub struct GraphStore {
    inner: InMemoryEdgeStore,
}
```

Map each `#[wasm_bindgen]` method to core delegation:
- `add_node()` → `self.inner.add_node()`
- `add_edge()` → `self.inner.add_edge()`
- `get_node()`, `get_edge()` → `self.inner.get_node()`, `self.inner.get_edge()`
- `get_outgoing()`, `get_incoming()` → `self.inner.get_outgoing()`, `self.inner.get_incoming()`
- `get_outgoing_by_label()` → `self.inner.get_outgoing_by_label()`
- `remove_node()`, `remove_edge()` → `self.inner.remove_node()`, `self.inner.remove_edge()`
- `node_count()`, `edge_count()` → `self.inner.node_count()`, `self.inner.edge_count()`
- `get_nodes_by_label()`, `get_edges_by_label()` → delegate with filter
- `get_neighbors()`, `get_all_node_ids()`, `get_all_edge_ids()` → delegate
- `has_node()`, `has_edge()` → delegate
- `out_degree()`, `in_degree()` → delegate
- `clear()` → `self.inner.clear()`

**Key decision on types:** WASM's `GraphNode` and `GraphEdge` are `#[wasm_bindgen]` structs with JsValue-compatible methods. Core's types might not have `#[wasm_bindgen]`. Two options:
- **Option A (preferred):** Keep WASM wrapper types but convert to/from core types internally
- **Option B:** Use core types directly if they can be `#[wasm_bindgen]`-annotated

Choose Option A for clean separation: WASM types handle JsValue conversion, core types handle logic.

**Verify:**
```powershell
cargo check --package velesdb-wasm
cargo test --package velesdb-wasm -- graph
```

**Done when:**
- `GraphStore` delegates all CRUD to `InMemoryEdgeStore`
- All `#[wasm_bindgen]` methods preserved with same API
- Node/edge data round-trips correctly through WASM ↔ Core conversion

---

### Task 2: Replace BFS/DFS with Core's Traversal Functions

**Files:** `crates/velesdb-wasm/src/graph.rs`

**Action:**
Replace WASM's manually implemented BFS and DFS with core's traversal functions:

```rust
// Before (graph.rs lines 313-349): Manual BFS with VecDeque
pub fn bfs_traverse(&self, source_id: u64, max_depth: usize, limit: usize) -> Result<JsValue, JsValue> {
    let mut queue: VecDeque<(u64, usize)> = VecDeque::new();
    // ... 30+ lines of manual BFS ...
}

// After: Delegate to core
pub fn bfs_traverse(&self, source_id: u64, max_depth: usize, limit: usize) -> Result<JsValue, JsValue> {
    let results = velesdb_core::graph::traversal::bfs(
        &self.inner, source_id, max_depth, limit, None,
    );
    let output: Vec<(u64, usize)> = results.iter()
        .map(|step| (step.node_id, step.depth))
        .collect();
    serde_wasm_bindgen::to_value(&output)
        .map_err(|e| JsValue::from_str(&e.to_string()))
}
```

Same for `dfs_traverse()`.

**Verify:**
```powershell
cargo test --package velesdb-wasm -- graph::graph_tests
```

**Done when:**
- `bfs_traverse()` delegates to `velesdb_core::graph::traversal::bfs()`
- `dfs_traverse()` delegates to `velesdb_core::graph::traversal::dfs()`
- Traversal results match previous implementation for identical graphs
- No manual BFS/DFS code remains in WASM

---

### Task 3: Update graph_persistence.rs and graph_worker.rs

**Files:** `crates/velesdb-wasm/src/graph_persistence.rs`, `crates/velesdb-wasm/src/graph_worker.rs`

**Action:**
These modules are WASM-specific (IndexedDB, Web Worker) and should be KEPT, but updated to work with the new GraphStore backed by core's InMemoryEdgeStore.

1. **graph_persistence.rs:** Update save/load to serialize core's types instead of WASM's internal types. The IndexedDB format may change — document migration path or bump version.

2. **graph_worker.rs:** Update to call the new delegating GraphStore methods. Since the GraphStore API is unchanged (same `#[wasm_bindgen]` methods), changes should be minimal.

3. If graph_persistence.rs uses `GraphStore`'s internal methods (`get_all_nodes_internal`, `get_all_edges_internal`), update to use core's equivalent iterators.

**Verify:**
```powershell
cargo check --package velesdb-wasm
```

**Done when:**
- `graph_persistence.rs` compiles with new GraphStore internals
- `graph_worker.rs` compiles with new GraphStore API
- IndexedDB save/load still works (format may change — document this)

---

## Verification

After all tasks complete:

```powershell
# Build
cargo check --package velesdb-wasm

# Tests
cargo test --package velesdb-wasm -- graph

# Core tests still pass
cargo test --workspace

# Clippy
cargo clippy --package velesdb-wasm -- -D warnings
```

## Success Criteria

- [ ] `GraphStore` delegates all CRUD to core's `InMemoryEdgeStore`
- [ ] BFS/DFS use core's `traversal::bfs()` / `traversal::dfs()`
- [ ] Zero manual BFS/DFS code in WASM
- [ ] WASM GraphStore API unchanged (same `#[wasm_bindgen]` methods)
- [ ] `graph_persistence.rs` and `graph_worker.rs` updated and compiling
- [ ] All graph tests pass
- [ ] `cargo check --package velesdb-wasm` passes

## Parallel Safety

**Exclusive write files:**
- `crates/velesdb-wasm/src/graph.rs` (major rewrite)
- `crates/velesdb-wasm/src/graph_persistence.rs` (type updates)
- `crates/velesdb-wasm/src/graph_worker.rs` (type updates)
- `crates/velesdb-wasm/src/graph_tests.rs` (test updates)

**Shared write files:**
- `crates/velesdb-wasm/src/lib.rs` (import updates)

**Shared read files:** `crates/velesdb-core/src/graph/`
**Conflicts with:** Plan 03, Plan 05 (shared write on `lib.rs`)

## Output

**Files modified:**
- `crates/velesdb-wasm/src/graph.rs` — GraphStore now delegates to core's InMemoryEdgeStore
- `crates/velesdb-wasm/src/graph_persistence.rs` — Updated for new internal types
- `crates/velesdb-wasm/src/graph_worker.rs` — Updated for new API
- `crates/velesdb-wasm/src/graph_tests.rs` — Updated to test delegation
- `crates/velesdb-wasm/src/lib.rs` — Updated graph imports
