---
phase: 2
plan: 3
name: Wire Subquery into SELECT WHERE Path + Quality Gates
wave: 2
depends_on: ["02-01"]
autonomous: true
---

# Phase 2 Plan 3: Wire Subquery into SELECT WHERE Path + Quality Gates

## Objective

Connect the scalar subquery executor into the SELECT WHERE path so that `Value::Subquery` in SELECT queries is resolved before filter conversion, instead of silently becoming `Value::Null`. Then run full quality gates and commit.

## Context

**Requirements addressed:** VP-002
**Phase goal contribution:** Fixes the SELECT path where `filter/conversion.rs` converts `Value::Subquery` → `Value::Null`, causing all SELECT queries with subqueries to silently produce wrong results.

**Current state:**
- `filter/conversion.rs` line 23-27: `Value::Subquery(_) => Value::Null` — silent data loss
- `execute_query()` in `mod.rs` extracts the WHERE clause and converts it to a `filter::Condition` via the `From` trait
- The `From<velesql::Condition> for filter::Condition` trait impl cannot execute subqueries (no collection access)

**Architecture:**
The `From` trait conversion is pure and stateless — it can't call `Collection::execute_scalar_subquery()`. Therefore, subqueries must be resolved **before** the filter conversion happens.

**Solution:** Add a pre-resolution step in `execute_query()` that walks the VelesQL condition tree and replaces all `Value::Subquery` with their resolved concrete values. Then the existing `From` conversion works correctly because it only sees concrete values.

## Tasks

### Task 1: Write failing tests for subquery in SELECT WHERE (RED)

**Files:** `crates/velesdb-core/src/collection/search/query/subquery_tests.rs`

**Action:**
Add integration tests to the subquery test file:

1. **test_select_where_with_subquery** — Execute a SELECT query where the WHERE clause contains a subquery comparison:
   ```sql
   SELECT * FROM products WHERE price < (SELECT AVG(price) FROM products)
   ```
   Setup: Collection with products at prices [10, 20, 30, 40, 50]. AVG = 30. Should return products with price < 30 (i.e., price 10 and 20).

2. **test_select_where_subquery_null_result** — Subquery targets empty collection or no matching rows → Value::Null → comparison is false → no results (not all results).

These tests should fail initially because subqueries resolve to Null in the SELECT path.

**Verify:**
```powershell
cargo test -p velesdb-core --lib subquery_tests::test_select_where 2>&1 | Select-Object -Last 5
# Should FAIL (RED phase)
```

**Done when:**
- Tests compile and fail (subquery resolves to Null, giving wrong result count)

---

### Task 2: Implement `resolve_subqueries_in_condition` pre-resolution step

**Files:** `crates/velesdb-core/src/collection/search/query/subquery.rs`

**Action:**
Add a method that recursively walks a `velesql::Condition` tree and resolves all `Value::Subquery` instances:

```rust
impl Collection {
    /// Resolves all subquery values in a condition tree before filter conversion.
    ///
    /// Walks the condition tree recursively and replaces every `Value::Subquery`
    /// with the concrete scalar result of executing that subquery.
    /// This must be called BEFORE converting `velesql::Condition` to `filter::Condition`.
    pub(crate) fn resolve_subqueries_in_condition(
        &self,
        condition: &crate::velesql::Condition,
        params: &HashMap<String, serde_json::Value>,
    ) -> Result<crate::velesql::Condition>
```

Implementation:
- Clone the condition
- For `Condition::Comparison`: resolve `cmp.value` if it's a `Value::Subquery`
- For `Condition::In`: resolve each value in the list
- For `Condition::Between`: resolve low/high bounds
- For `Condition::And/Or/Not/Group`: recurse into children
- All other variants: pass through unchanged

**Verify:**
```powershell
cargo test -p velesdb-core --lib subquery_tests 2>&1 | Select-Object -Last 5
```

**Done when:**
- Method compiles and is tested via existing subquery tests
- Condition tree with subqueries is transformed into one with only concrete values

---

### Task 3: Wire pre-resolution into `execute_query`

**Files:** `crates/velesdb-core/src/collection/search/query/mod.rs`

**Action:**
In `execute_query()`, after extracting `filter_condition` from the WHERE clause, add a pre-resolution step:

```rust
// VP-002: Resolve subquery values before filter conversion
if let Some(ref cond) = filter_condition {
    filter_condition = Some(self.resolve_subqueries_in_condition(cond, params)?);
}
```

This must happen BEFORE any code that converts `velesql::Condition` to `filter::Condition` via the `From` trait.

Also update the `filter/conversion.rs` to replace the silent `Value::Null` with a clear error for any `Value::Subquery` that somehow reaches conversion (defense in depth):

```rust
crate::velesql::Value::Subquery(_) => {
    // VP-002: Subqueries should be resolved before reaching filter conversion.
    // If we get here, it means resolve_subqueries_in_condition was not called.
    // Return Null as safe fallback, but log a warning.
    tracing::warn!("Subquery reached filter conversion without resolution — this is a bug");
    Value::Null
}
```

**Verify:**
```powershell
cargo test -p velesdb-core --lib subquery_tests 2>&1 | Select-Object -Last 10
# All tests should now pass (GREEN phase)
```

**Done when:**
- SELECT queries with subqueries execute correctly
- Previously silent Null conversion now only happens as fallback with warning
- All tests pass

---

### Task 4: Full quality gates and commit

**Files:** All modified files

**Action:**
Run the complete quality gate suite:

```powershell
cargo fmt --all
cargo clippy -p velesdb-core -- -D warnings
cargo test -p velesdb-core --lib
cargo deny check
```

Fix any issues. Then commit:

```powershell
git add -A
git commit -m "feat(velesql): implement scalar subquery execution engine [VP-002]

Phase 2 of v4-verify-promise milestone:

- Create subquery executor that runs inner SELECT and returns scalar Value
- Wire into MATCH WHERE: resolve_where_param now handles Value::Subquery
- Wire into SELECT WHERE: pre-resolve subqueries before filter conversion
- Correlated subqueries resolve outer references from node payload context
- Empty subquery results → Value::Null (explicit, not silent)
- Defense in depth: warn log if subquery reaches filter conversion unresolved

Tests: N new tests for subquery execution, MATCH integration, SELECT integration
Quality: fmt, clippy -D warnings, deny check, all tests pass"
```

**Verify:**
```powershell
cargo fmt --all --check
cargo clippy -p velesdb-core -- -D warnings
cargo test -p velesdb-core --lib
cargo deny check
```

**Done when:**
- All 4 quality gates pass (fmt, clippy, deny, test)
- Clean commit on branch
- No silent `Value::Null` conversion for subqueries

---

## Verification

After all tasks complete:

```powershell
cargo fmt --all --check
cargo clippy -p velesdb-core -- -D warnings
cargo test -p velesdb-core --lib
cargo deny check
cargo build --release
```

## Success Criteria

- [ ] SELECT queries with subquery comparisons execute correctly
- [ ] `filter/conversion.rs` no longer silently converts `Value::Subquery` → `Value::Null`
- [ ] Pre-resolution step in `execute_query` handles all condition types
- [ ] All existing tests pass (no regression)
- [ ] At least 2 new SELECT + subquery integration tests
- [ ] All quality gates pass
- [ ] Clean commit

## Output

**Files created:**
- (None — uses files from Plan 02-01)

**Files modified:**
- `crates/velesdb-core/src/collection/search/query/subquery.rs` — `resolve_subqueries_in_condition`
- `crates/velesdb-core/src/collection/search/query/subquery_tests.rs` — SELECT integration tests
- `crates/velesdb-core/src/collection/search/query/mod.rs` — Pre-resolution step in `execute_query`
- `crates/velesdb-core/src/filter/conversion.rs` — Defense-in-depth warning for unresolved subqueries
