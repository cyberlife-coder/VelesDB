---
phase: 01-foundation-fixes
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/velesdb-core/src/lib.rs
  - crates/velesdb-core/src/**/*.rs
  - crates/velesdb-core/src/**/**/*.rs
autonomous: true
must_haves:
  truths:
    - No println! or eprintln! in library code
    - All logging uses tracing macros (info!, debug!, warn!, error!)
    - Log levels are appropriate for message type
    - Production paths use structured logging
  artifacts:
    - path: crates/velesdb-core/src/lib.rs
      provides: Line 437 and all logging converted to tracing
    - path: crates/velesdb-core/src/storage/mmap.rs
      provides: Storage layer using tracing:: macros
    - path: crates/velesdb-core/src/index/hnsw/native/graph.rs
      provides: Index layer using tracing:: macros
  key_links:
    - from: Error conditions
      to: Log output
      via: tracing::error! or tracing::warn!
      pattern: "tracing::(error|warn|info|debug)!"
    - from: Debug information
      to: Log output
      via: tracing::debug!
      pattern: "tracing::debug!"
---

<objective>
Replace all `println!` and `eprintln!` macros in library code with appropriate `tracing` macros (info!, debug!, warn!, error!).

Purpose: Library code should never write directly to stdout/stderr; use structured logging for production observability and proper log level control.
Output: Zero `println!`/`eprintln!` in library code; all logging uses `tracing` macros with appropriate levels.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md

# Target file with known eprintln
@crates/velesdb-core/src/lib.rs

# High-risk files for logging audit
@crates/velesdb-core/src/storage/mmap.rs
@crates/velesdb-core/src/index/hnsw/native/graph.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit All Print Statements in Library Code</name>
  <files>crates/velesdb-core/src/lib.rs, crates/velesdb-core/src/**/*.rs</files>
  <action>
Find all `println!`, `eprintln!`, `print!`, and `eprint!` in the library code:

```bash
# Find all print statements
grep -rn "println!\|eprintln!\|print!\|eprint!" crates/velesdb-core/src/ --include="*.rs" | grep -v "//" | grep -v "tests/"

# Also check for dbg! which writes to stderr
grep -rn "dbg!" crates/velesdb-core/src/ --include="*.rs" | grep -v "//" | grep -v "tests/"
```

Categorize each occurrence:
1. **Library code** (should migrate to tracing): src/*.rs, non-test modules
2. **Test code** (can keep println!): tests/, #[cfg(test)] blocks, examples/
3. **CLI/main** (may keep println! for user output): crates/velesdb-cli/, velesdb-server/

Document each location with:
- File path and line number
- Current print statement
- Appropriate tracing level based on context
- Reason for the log (error, debug, info)

Tracing level guidelines:
- `tracing::error!`: Actual errors that need attention
- `tracing::warn!`: Warning conditions, recoverable issues
- `tracing::info!`: Important operational events (initialization, config)
- `tracing::debug!`: Detailed debugging information
- `tracing::trace!`: Very detailed tracing (rarely needed)

Known location from REQUIREMENTS.md:
- `crates/velesdb-core/src/lib.rs:437` (eprintln!)

Create audit report: `.planning/phases/01-foundation-fixes/01-03-print-audit.md`
  </action>
  <verify>
Audit report exists listing all print statements
Each categorized as library/test/cli
Tracing level recommended for each
  </verify>
  <done>Complete audit report created with all print/eprint/dbg statements identified and categorized</done>
</task>

<task type="auto">
  <name>Task 2: Migrate lib.rs Line 437 and High-Priority Files</name>
  <files>crates/velesdb-core/src/lib.rs</files>
  <action>
Start with the known location from REQUIREMENTS.md:

**Line 437 in lib.rs:**
- Locate the exact `eprintln!` at line 437
- Determine context: Is it an error? Debug info? Warning?
- Replace with appropriate tracing macro:

Examples:
```rust
// ❌ BEFORE
eprintln!("Failed to initialize index: {}", err);

// ✅ AFTER - If it's an error condition
tracing::error!(error = %err, "Failed to initialize index");

// ✅ AFTER - If it's debug information during development
tracing::debug!(error = %err, "Index initialization failed");

// ❌ BEFORE
println!("Loaded {} vectors", count);

// ✅ AFTER - Operational information
tracing::info!(vector_count = count, "Vectors loaded successfully");

// ❌ BEFORE
dbg!(&config);

// ✅ AFTER - Debug output
tracing::debug!(?config, "Configuration loaded");
```

Structured logging syntax:
- `tracing::info!(key = value, "message")` for key-value pairs
- `tracing::debug!(?variable, "message")` for debug formatting
- `tracing::error!(error = %err, "message")` for display formatting

Verify the file compiles after changes:
```bash
cargo check -p velesdb-core
```
  </action>
  <verify>
```bash
grep -n "println!\|eprintln!" crates/velesdb-core/src/lib.rs
# Should return no results (or only in comments)
grep -n "tracing::" crates/velesdb-core/src/lib.rs | head -10
# Should show tracing macros used
cargo check -p velesdb-core
# Compiles successfully
```
  </verify>
  <done>lib.rs line 437 and all lib.rs print statements migrated to tracing macros</done>
</task>

<task type="auto">
  <name>Task 3: Migrate Remaining Library Code Files</name>
  <files>crates/velesdb-core/src/storage/mmap.rs, crates/velesdb-core/src/index/hnsw/native/graph.rs, crates/velesdb-core/src/**/*.rs</files>
  <action>
Process remaining files from the audit report, prioritizing:
1. **Storage layer** (mmap.rs) - persistence errors need proper logging
2. **Index layer** (graph.rs) - performance-critical, use debug/trace appropriately
3. **Core modules** - error paths, initialization
4. **Utility modules** - info/debug as appropriate

For each file:
1. Read the file to understand context of each print statement
2. Determine appropriate tracing level based on message importance
3. Replace with structured logging:

```rust
// Error conditions (persistence failures, I/O errors)
tracing::error!(path = %path, error = %e, "Failed to mmap file");

// Warnings (recoverable issues, fallbacks)
tracing::warn!(attempt = retry_count, "Retrying connection");

// Info (operational milestones)
tracing::info!(collection = name, dimensions = dims, "Collection created");

// Debug (detailed state for troubleshooting)
tracing::debug!(vector_id = id, "Processing vector insertion");

// Trace (very detailed, performance-sensitive)
tracing::trace!("Entering inner loop iteration {}", i);
```

Skip files in:
- `tests/` directories
- `examples/` directories
- `benches/` directories
- `#[cfg(test)]` blocks within files

After each file:
```bash
cargo check -p velesdb-core
```

Run full verification:
```bash
cargo clippy -p velesdb-core -- -D warnings
grep -rn "println!\|eprintln!" crates/velesdb-core/src/ --include="*.rs" | grep -v "//" | grep -v "tests/"
# Should return empty
```
  </action>
  <verify>
```bash
# Verify no print statements remain in library code
grep -rn "println!\|eprintln!" crates/velesdb-core/src/ --include="*.rs" | grep -v "//" | grep -v "tests/" | grep -v "examples/"
# Should return empty

# Verify tracing is used
grep -rn "tracing::" crates/velesdb-core/src/ --include="*.rs" | wc -l
# Should show positive count

# Build and test
cargo build --workspace
cargo test --workspace
```
  </verify>
  <done>All library code files migrated; zero println!/eprintln! in production code; build and tests pass</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Verify no print statements in library code:
   ```bash
   grep -rn "println!\|eprintln!" crates/velesdb-core/src/ --include="*.rs" | grep -v "//" | grep -v "tests/" | grep -v "examples/"
   # Should be empty
   ```
2. Verify tracing is properly imported and used:
   ```bash
   grep -rn "use tracing::" crates/velesdb-core/src/ --include="*.rs"
   ```
3. Run full CI gates:
   ```bash
   cargo build --workspace
   cargo clippy --workspace -- -D warnings
   cargo test --workspace
   ```
4. Check that log levels are appropriate (no `error!` for debug info, etc.)

Success indicators:
- Zero `println!`/`eprintln!` in library source files
- All library logging uses `tracing::` macros
- Appropriate log levels used (error/warn for issues, debug/trace for diagnostics)
- CI gates pass
- No functional changes (tests still pass)
</verification>

<success_criteria>
- Line 437 in lib.rs converted from eprintln! to tracing macro
- All library code uses tracing::info!, debug!, warn!, error! exclusively
- Test/example code can still use println! (intentionally excluded)
- No println!/eprintln! found in production paths
- Structured logging format used (key=value pairs where appropriate)
- CI gates pass: `cargo build`, `cargo clippy`, `cargo test`
- Log levels are semantically correct (error for failures, debug for diagnostics)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-fixes/01-03-SUMMARY.md` with:
- Count of print statements replaced
- Breakdown by tracing level used (error/warn/info/debug/trace)
- List of files modified
- Examples of before/after conversions
- Any files excluded (tests, examples) with rationale
</output>
