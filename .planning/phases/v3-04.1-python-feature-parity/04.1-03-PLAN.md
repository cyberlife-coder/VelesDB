---
phase: 4.1
plan: 03
name: Graph Direct API on Vectorstore
wave: 3
depends_on: [04.1-02]
autonomous: true
parallel_safe: false
---

# Phase 4.1 Plan 03: Graph Direct API on Vectorstore

## Objective

Add `add_edge()`, `get_edges()`, `traverse_graph()`, and `get_node_degree()` directly on both LangChain and LlamaIndex vectorstores. Currently graph operations require separate GraphRetriever/GraphLoader classes with REST calls. This plan brings them to the vectorstore itself, delegating to the `velesdb` SDK's Collection API — zero HTTP, zero business logic.

## Context

**Requirements addressed:** Audit gaps #9 (get_node_degree), #10 (graph direct API on vectorstore)  
**Phase goal contribution:** 4 of 10 missing features closed. Agents can build and query knowledge graphs from the same vectorstore object they use for search.

## Tasks

### Task 1: Add new validators to velesdb_common

**Files:** `integrations/common/src/velesdb_common/security.py`, `integrations/common/tests/test_security.py`

**Action:**
Add 2 new validators to `velesdb_common/security.py`:

1. **`validate_label(label: str) -> str`** — Validate edge/node label.
   - Same pattern as `validate_collection_name()`: non-empty, alphanumeric + underscore + hyphen, max 128 chars.
   - Reject null bytes, path traversal, special chars.
   - Return sanitized label string.

2. **`validate_node_id(node_id: int) -> int`** — Validate graph node ID.
   - Must be a positive integer (>= 0).
   - Must fit in 63-bit range (0 to 2^63 - 1) — matching VelesDB's i64 IDs.
   - Reject negative, None, non-int.
   - Return validated int.

Add both to `__init__.py` re-exports.

**Tests** in `test_security.py`:
- `test_validate_label_valid` — "PERSON", "KNOWS", "works_at" all pass
- `test_validate_label_empty` — SecurityError
- `test_validate_label_injection` — SecurityError on `"; DROP TABLE`
- `test_validate_label_too_long` — SecurityError on 200-char label
- `test_validate_node_id_valid` — 0, 1, 42, 2**62 all pass
- `test_validate_node_id_negative` — SecurityError
- `test_validate_node_id_too_large` — SecurityError on 2**64
- `test_validate_node_id_non_int` — SecurityError on "abc"

**Verify:**
```bash
cd integrations/common && python -m pytest tests/test_security.py -v -k "label or node_id"
```

**Done when:**
- Both validators exist and are re-exported from `velesdb_common`
- 8+ new tests pass
- Zero regression on existing 95 common tests

---

### Task 2: Add 4 graph methods to LangChain VelesDBVectorStore

**Files:** `integrations/langchain/src/langchain_velesdb/vectorstore.py`

**Action:**
Add these 4 methods after the `match_query()` method added in Plan 02:

1. **`add_edge(id, source, target, label, metadata=None)`** — Instance method.
   - Validate: `validate_node_id(id)`, `validate_node_id(source)`, `validate_node_id(target)`, `validate_label(label)`.
   - Delegate to `self._collection.add_edge(id=id, source=source, target=target, label=label, metadata=metadata or {})`.
   - Returns `None`.
   - Raises `ValueError` if collection not initialized.

2. **`get_edges(label=None)`** — Instance method.
   - If `label` provided, validate with `validate_label()`.
   - Delegate to `self._collection.get_edges_by_label(label)` or `self._collection.get_edges()`.
   - Returns `List[dict]` with keys: id, source, target, label, properties.
   - Raises `ValueError` if collection not initialized.

3. **`traverse_graph(source, max_depth=2, strategy="bfs", limit=100)`** — Instance method.
   - Validate: `validate_node_id(source)`, `validate_k(limit)`.
   - Strategy must be "bfs" or "dfs" — raise ValueError otherwise.
   - Delegate to `self._collection.traverse(source=source, max_depth=max_depth, strategy=strategy, limit=limit)`.
   - Convert results to `List[Document]`: each traversal result's payload → Document.
   - Returns `List[Document]` with metadata including `graph_depth` and `target_id`.

4. **`get_node_degree(node_id)`** — Instance method.
   - Validate: `validate_node_id(node_id)`.
   - Delegate to `self._collection.get_node_degree(node_id)`.
   - Returns `dict` with keys: `node_id`, `in_degree`, `out_degree`, `total_degree`.
   - Raises `ValueError` if collection not initialized.

Import `validate_label` and `validate_node_id` from `velesdb_common` (add to existing import block).

**Verify:**
```bash
cd integrations/langchain && python -c "from langchain_velesdb import VelesDBVectorStore; print([m for m in dir(VelesDBVectorStore) if m in ('add_edge','get_edges','traverse_graph','get_node_degree')])"
```

**Done when:**
- All 4 methods exist on LangChain VelesDBVectorStore
- Each has docstring with Args/Returns/Raises and usage example
- All inputs validated
- `traverse_graph()` returns framework-native `List[Document]`

---

### Task 3: Add 4 graph methods to LlamaIndex VelesDBVectorStore

**Files:** `integrations/llamaindex/src/llamaindex_velesdb/vectorstore.py`

**Action:**
Add the same 4 methods to LlamaIndex `VelesDBVectorStore`. Identical validation and delegation, but adapted return types:

1. **`add_edge()`** — Same as LangChain. Returns `None`.
2. **`get_edges(label=None)`** — Same. Returns `List[dict]`.
3. **`traverse_graph(source, max_depth=2, strategy="bfs", limit=100)`** — Same delegation but returns `List[NodeWithScore]`.
   - Each result → `NodeWithScore(node=TextNode(text=text, id_=node_id, metadata={...}), score=depth_score)`.
   - Score: `1.0 - (depth / (max_depth + 1))` — closer nodes get higher scores.
4. **`get_node_degree(node_id)`** — Same. Returns `dict`.

Import `validate_label` and `validate_node_id` from `velesdb_common`.

Place after `match_query()`.

**Verify:**
```bash
cd integrations/llamaindex && python -c "from llamaindex_velesdb import VelesDBVectorStore; print([m for m in dir(VelesDBVectorStore) if m in ('add_edge','get_edges','traverse_graph','get_node_degree')])"
```

**Done when:**
- All 4 methods exist on LlamaIndex VelesDBVectorStore
- `traverse_graph()` returns `List[NodeWithScore]` with depth-based scoring
- Same validation pattern as LangChain

---

### Task 4: Add tests for graph methods

**Files:** `integrations/langchain/tests/test_graph_api.py`, `integrations/llamaindex/tests/test_graph_api.py`

**Action:**
Create new test files with mock-based tests:

**LangChain tests (≥14 tests):**
- `test_add_edge_delegates` — mock `collection.add_edge()` called with correct params
- `test_add_edge_validates_ids` — SecurityError on negative IDs
- `test_add_edge_validates_label` — SecurityError on injection label
- `test_add_edge_no_collection` — ValueError when not initialized
- `test_get_edges_all` — mock `collection.get_edges()` → verify `List[dict]`
- `test_get_edges_by_label` — mock `collection.get_edges_by_label("KNOWS")`
- `test_get_edges_validates_label` — SecurityError on bad label
- `test_get_edges_no_collection` — ValueError
- `test_traverse_graph_returns_documents` — mock traverse → verify `List[Document]`
- `test_traverse_graph_invalid_strategy` — ValueError on "invalid"
- `test_traverse_graph_validates_source` — SecurityError on negative
- `test_traverse_graph_metadata_includes_depth` — verify `graph_depth` in metadata
- `test_get_node_degree_returns_dict` — mock `collection.get_node_degree()` → dict
- `test_get_node_degree_validates_id` — SecurityError on negative

**LlamaIndex tests (≥14 tests):** Mirror with LlamaIndex types:
- `traverse_graph` returns `List[NodeWithScore]` with depth-based scores

Mock data:
```python
# traverse mock return
[{"target_id": 200, "depth": 1, "payload": {"text": "Connected node", "node_id": "200"}},
 {"target_id": 300, "depth": 2, "payload": {"text": "Second hop", "node_id": "300"}}]

# get_node_degree mock return
{"node_id": 100, "in_degree": 3, "out_degree": 5, "total_degree": 8}
```

**Verify:**
```bash
cd integrations/langchain && python -m pytest tests/test_graph_api.py -v
cd integrations/llamaindex && python -m pytest tests/test_graph_api.py -v
```

**Done when:**
- All 28+ tests pass (14 per integration)
- No server dependency
- Depth-based scoring verified in LlamaIndex tests

---

## Verification

After all tasks complete:

```bash
cd integrations/common && python -m pytest tests/ -v --tb=short
cd integrations/langchain && python -m pytest tests/ -v --tb=short
cd integrations/llamaindex && python -m pytest tests/ -v --tb=short
```

## Success Criteria

- [ ] `validate_label()` and `validate_node_id()` in velesdb_common + 8 tests
- [ ] `add_edge()` validates and delegates in both integrations
- [ ] `get_edges()` with optional label filter in both
- [ ] `traverse_graph()` returns `List[Document]` (LC) / `List[NodeWithScore]` (LI)
- [ ] `get_node_degree()` returns `dict` in both
- [ ] 36+ new tests pass (8 common + 14 LC + 14 LI)
- [ ] Zero regression on existing tests + Plan 01/02 tests
- [ ] GraphRetriever/GraphLoader remain unchanged and working

## Parallel Safety

**Exclusive write files:**
- `integrations/common/src/velesdb_common/security.py` — new validators
- `integrations/common/src/velesdb_common/__init__.py` — re-exports
- `integrations/common/tests/test_security.py` — new tests
- `integrations/langchain/src/langchain_velesdb/vectorstore.py` — +4 methods
- `integrations/langchain/tests/test_graph_api.py` (new)
- `integrations/llamaindex/src/llamaindex_velesdb/vectorstore.py` — +4 methods
- `integrations/llamaindex/tests/test_graph_api.py` (new)

**Shared read files:** none beyond standard imports

**Conflicts with:** Plans 04.1-01, 04.1-02 write to same files → **sequential after Plan 02**

## Output

**Files modified:**
- `integrations/common/src/velesdb_common/security.py` — +2 validators
- `integrations/common/src/velesdb_common/__init__.py` — +2 re-exports
- `integrations/common/tests/test_security.py` — +8 tests
- `integrations/langchain/src/langchain_velesdb/vectorstore.py` — +4 methods
- `integrations/llamaindex/src/llamaindex_velesdb/vectorstore.py` — +4 methods

**Files created:**
- `integrations/langchain/tests/test_graph_api.py` — 14+ tests
- `integrations/llamaindex/tests/test_graph_api.py` — 14+ tests
