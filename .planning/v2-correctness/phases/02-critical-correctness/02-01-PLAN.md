---
phase: 2
plan: 1
name: GPU WGSL Shaders & Metric Dispatch
wave: 1
depends_on: none
autonomous: true
---

# Phase 2 Plan 1: GPU WGSL Shaders & Metric Dispatch

## Objective

Replace the fake CPU-loop GPU implementations of Euclidean and DotProduct with real WGSL compute shaders dispatched on the GPU. Fix `search_brute_force_gpu` to respect the collection's configured `DistanceMetric` instead of hardcoding cosine.

## Context

**Requirements addressed:** C-01, C-03
**Phase goal contribution:** Eliminates mathematically wrong GPU results — the most critical correctness finding.

**Current state:**
- `batch_cosine_similarity` — real WGSL shader ✅
- `batch_euclidean_distance` — CPU loop via `simd_native::euclidean_native` ❌
- `batch_dot_product` — CPU loop via `simd_native::dot_product_native` ❌
- `search_brute_force_gpu` — hardcodes `batch_cosine_similarity` regardless of metric ❌

## Tasks

### Task 1: Write Euclidean WGSL shader + pipeline

**Files:** `crates/velesdb-core/src/gpu/gpu_backend.rs`

**Action:**
1. Add `EUCLIDEAN_SHADER` const (WGSL) computing `sqrt(Σ(q[i]-v[i])²)` per vector:
```wgsl
@compute @workgroup_size(256)
fn batch_euclidean(@builtin(global_invocation_id) id: vec3<u32>) {
    let idx = id.x;
    if (idx >= params.num_vectors) { return; }
    let dim = params.dimension;
    let offset = idx * dim;
    var sum: f32 = 0.0;
    for (var i: u32 = 0u; i < dim; i = i + 1u) {
        let diff = query[i] - vectors[offset + i];
        sum = sum + diff * diff;
    }
    results[idx] = sqrt(sum);
}
```
2. Add `euclidean_pipeline: wgpu::ComputePipeline` field to `GpuAccelerator`
3. Initialize pipeline in `GpuAccelerator::new()` — same bind group layout as cosine
4. Rewrite `batch_euclidean_distance` to use the GPU pipeline (same buffer setup pattern as `batch_cosine_similarity`)
5. Change return type to `Result<Vec<f32>>` (matching cosine's signature)

**Verify:**
```powershell
cargo test --package velesdb-core --features gpu -- gpu_backend_tests --test-threads=1
```

**Done when:**
- `batch_euclidean_distance` runs on GPU (not CPU loop)
- Returns `Result<Vec<f32>>` like cosine
- All existing euclidean GPU tests pass

---

### Task 2: Write DotProduct WGSL shader + pipeline

**Files:** `crates/velesdb-core/src/gpu/gpu_backend.rs`

**Action:**
1. Add `DOT_PRODUCT_SHADER` const (WGSL) computing `Σ(q[i]*v[i])`:
```wgsl
@compute @workgroup_size(256)
fn batch_dot_product(@builtin(global_invocation_id) id: vec3<u32>) {
    let idx = id.x;
    if (idx >= params.num_vectors) { return; }
    let dim = params.dimension;
    let offset = idx * dim;
    var dot: f32 = 0.0;
    for (var i: u32 = 0u; i < dim; i = i + 1u) {
        dot = dot + query[i] * vectors[offset + i];
    }
    results[idx] = dot;
}
```
2. Add `dot_product_pipeline: wgpu::ComputePipeline` field
3. Initialize in `GpuAccelerator::new()`
4. Rewrite `batch_dot_product` to use GPU pipeline
5. Change return type to `Result<Vec<f32>>`

**Verify:**
```powershell
cargo test --package velesdb-core --features gpu -- gpu_backend_tests --test-threads=1
```

**Done when:**
- `batch_dot_product` runs on GPU (not CPU loop)
- Returns `Result<Vec<f32>>`
- Dot product tests pass (orthogonal=0, parallel=expected sum)

---

### Task 3: Fix metric dispatch in search_brute_force_gpu

**Files:** `crates/velesdb-core/src/index/hnsw/index/search.rs`

**Action:**
Replace the hardcoded `gpu.batch_cosine_similarity(...)` call with metric-aware dispatch:
```rust
let results = match self.metric {
    DistanceMetric::Cosine => gpu.batch_cosine_similarity(&flat_vectors, query, self.dimension),
    DistanceMetric::Euclidean => gpu.batch_euclidean_distance(&flat_vectors, query, self.dimension),
    DistanceMetric::DotProduct => gpu.batch_dot_product(&flat_vectors, query, self.dimension),
    other => {
        tracing::warn!("GPU not implemented for {:?}, falling back to CPU", other);
        return None; // Caller falls back to CPU search
    }
};
```

Ensure all 3 GPU batch methods return `Result<Vec<f32>>` for consistent error handling.

**Verify:**
```powershell
cargo test --package velesdb-core --features gpu -- search_brute_force --test-threads=1
cargo clippy --package velesdb-core --features gpu -- -D warnings
```

**Done when:**
- `search_brute_force_gpu` dispatches to correct GPU method per metric
- Hamming/Jaccard → returns `None` with `tracing::warn!`
- No `batch_cosine_similarity` hardcoded in search path
- Clippy clean

---

## Verification

After all tasks complete:

```powershell
# All GPU tests
cargo test --package velesdb-core --features gpu -- gpu --test-threads=1

# All HNSW search tests
cargo test --package velesdb-core --features gpu -- search_brute_force --test-threads=1

# Quality gates
cargo fmt --all --check
cargo clippy --workspace --features persistence,gpu,update-check --exclude velesdb-python -- -D warnings
```

## Success Criteria

- [ ] `batch_euclidean_distance` uses real WGSL compute shader
- [ ] `batch_dot_product` uses real WGSL compute shader
- [ ] Both return `Result<Vec<f32>>` (consistent with cosine)
- [ ] `search_brute_force_gpu` dispatches on `self.metric`
- [ ] Hamming/Jaccard → CPU fallback with `tracing::warn!`
- [ ] GPU vs CPU equivalence: `|gpu_result - cpu_result| < 1e-5` for all 3 metrics
- [ ] All existing GPU tests pass

## Output

**Files modified:**
- `crates/velesdb-core/src/gpu/gpu_backend.rs` — 2 new WGSL shaders + pipelines, rewrite batch methods
- `crates/velesdb-core/src/gpu/gpu_backend_tests.rs` — GPU-CPU equivalence tests
- `crates/velesdb-core/src/index/hnsw/index/search.rs` — metric dispatch in brute force
