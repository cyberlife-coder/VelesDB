---
phase: 4
plan: 2
name: Storage Integrity
wave: 1
depends_on: none
autonomous: true
---

# Phase 4 Plan 2: Storage Integrity

## Objective

Add per-entry CRC32 to WAL for corruption detection, implement batch flush for `LogPayloadStorage` to reduce I/O syscalls, and replace the WAL position lock with an `AtomicU64` for lock-free snapshot decisions.

## Context

**Requirements addressed:** D-05, D-06, D-07
**Phase goal contribution:** Data integrity (CRC detects bit-flips), write throughput (batch flush), and reduced lock contention (atomic snapshot check).

**Current state:**
- WAL has no per-entry checksum — bit-flips or partial writes go undetected during replay
- `LogPayloadStorage::store()` flushes after each entry — N entries = N flushes
- `should_create_snapshot` acquires a write lock on WAL just to read file position

## Tasks

### Task 1: WAL per-entry CRC32 [D-05]

**Files:** `crates/velesdb-core/src/storage/log_payload.rs`

**Action:**
1. Define entry header format: `[len:u32][crc32:u32][payload:len bytes]`
2. On write: compute CRC32 of payload (use `crc32fast` crate — already in ecosystem, or add to `Cargo.toml`), write header + payload
3. On replay: read header, read payload, verify CRC32 matches. If mismatch → return `StorageError::CorruptedEntry { offset, expected_crc, actual_crc }`
4. Enabled by default — no opt-out needed
5. Add `StorageError::CorruptedEntry` variant if not present

**Verify:**
```powershell
cargo test --package velesdb-core --features persistence -- log_payload
```

**Done when:**
- Every WAL entry has `[len][crc32][payload]` format
- CRC32 verified during replay
- Corrupted entry → clear error (not silent data loss)
- All storage tests pass

---

### Task 2: LogPayloadStorage batch flush [D-06]

**Files:** `crates/velesdb-core/src/storage/log_payload.rs`

**Action:**
Add a new method alongside the existing `store()`:
```rust
/// Store multiple entries with a single flush.
/// Reduces I/O syscalls from N to 1 for batch insertions.
pub fn store_batch(&self, items: &[(u64, &[u8])]) -> Result<()> {
    let mut writer = self.writer.lock();
    for (id, payload) in items {
        let crc = crc32fast::hash(payload);
        writer.write_all(&(payload.len() as u32).to_le_bytes())?;
        writer.write_all(&crc.to_le_bytes())?;
        writer.write_all(payload)?;
    }
    writer.flush()?; // Single flush for all entries
    Ok(())
}
```

The existing `store()` remains unchanged for single insertions — backward compatible.

**Verify:**
```powershell
cargo test --package velesdb-core --features persistence -- log_payload_tests::test_store_batch
```

**Done when:**
- `store_batch()` writes N entries with 1 flush
- Existing `store()` unchanged
- Batch entries are CRC-protected (from Task 1)
- All storage tests pass

---

### Task 3: Snapshot lock → AtomicU64 [D-07]

**Files:** `crates/velesdb-core/src/storage/log_payload.rs` (or snapshot logic file)

**Action:**
1. Add `wal_position: AtomicU64` field to the storage struct
2. Update `wal_position` on each write (in `store()` and `store_batch()`) using `Ordering::Release`
3. Replace the lock-based position read in `should_create_snapshot`:
```rust
// BEFORE: acquires write lock just to read position
fn should_create_snapshot(&self) -> bool {
    let wal = self.wal.write();
    let pos = wal.get_ref().metadata().unwrap().len();
    pos >= self.snapshot_threshold
}

// AFTER: lock-free read
fn should_create_snapshot(&self) -> bool {
    let pos = self.wal_position.load(Ordering::Acquire);
    pos >= self.snapshot_threshold
}
```

**Verify:**
```powershell
cargo test --package velesdb-core --features persistence -- snapshot
cargo test --package velesdb-core --features persistence -- log_payload
```

**Done when:**
- `should_create_snapshot` is lock-free (no WAL lock acquisition)
- `AtomicU64` tracks WAL position accurately
- All snapshot and storage tests pass

---

## Verification

After all tasks complete:

```powershell
cargo test --package velesdb-core --features persistence -- storage
cargo test --workspace --features persistence,gpu,update-check --exclude velesdb-python
cargo fmt --all --check
cargo clippy --workspace --features persistence,gpu,update-check --exclude velesdb-python -- -D warnings
```

## Success Criteria

- [ ] WAL CRC32 detects corruption during replay
- [ ] `store_batch()` flushes once for N entries
- [ ] `should_create_snapshot` lock-free (`AtomicU64`)
- [ ] No regression in storage tests
- [ ] All quality gates pass

## Output

**Files modified:**
- `crates/velesdb-core/src/storage/log_payload.rs` — CRC, batch flush, atomic position
- `crates/velesdb-core/Cargo.toml` — add `crc32fast` dependency if needed

**Files modified:**
- `crates/velesdb-core/src/storage/log_payload_tests.rs` — CRC and batch tests
