---
phase: 7
plan: 1
name: f64 Scalar Reference with Higham Error Bound
wave: 1
depends_on: none
autonomous: true
---

# Phase 7 Plan 1: f64 Scalar Reference with Higham Error Bound

## Objective

Fix the flaky SIMD property tests at their root cause: the current f32 scalar reference
is NOT a ground truth — it has the same order of rounding error as SIMD, just in a
different direction. Replace all scalar references with f64 accumulation and use
Higham's proven `γ(N) × condition_number` forward error bound as the tolerance.

## Context

**Requirements addressed:** TEST-08
**Phase goal contribution:** Eliminates flakiness with mathematically proven bounds — no arbitrary constants

### Why the current approach fails

The current tests compare **f32 SIMD** against **f32 scalar** with fixed tolerances.
Both are wrong by O(N × ε × condition) vs the true mathematical result, but in different
directions. When both errors happen to diverge, the delta exceeds the fixed tolerance.

**The fix:** Use f64 as ground truth. f64 has 52-bit mantissa vs f32's 23-bit, so f64
accumulation of f32 products is essentially exact for our purposes (error < 10⁻⁹ for
N=1536). Then we measure each f32 SIMD result against this proper reference.

### Higham's forward error bound (proven)

From "Accuracy and Stability of Numerical Algorithms" (Higham, 2002):

For a sum of N floating-point terms computed in any order:
```
|computed_sum - exact_sum| ≤ γ(N) × Σ|terms|
```
where `γ(N) = N × u / (1 - N × u) ≈ N × u` for `N × u ≪ 1`,
and `u = f32::EPSILON / 2` (unit roundoff).

`Σ|terms|` is the **condition number** of the summation — it measures how much
catastrophic cancellation amplifies rounding errors.

This bound holds for ANY summation order (left-to-right, 4-accumulator, pairwise, etc.).

## Tasks

### Task 1: Replace scalar references with f64 accumulation

**Files:** `crates/velesdb-core/tests/simd_property_tests.rs`

**Action:**
Replace ALL scalar reference functions with f64 versions that return `(f64, f64)` —
the reference value and the condition number (sum of absolute terms):

```rust
/// f64 ground truth for dot product.
/// Returns (exact_sum, condition_number) where condition_number = Σ|a[i]×b[i]|.
fn reference_dot_f64(a: &[f32], b: &[f32]) -> (f64, f64) {
    let mut sum = 0.0_f64;
    let mut abs_sum = 0.0_f64;
    for (x, y) in a.iter().zip(b.iter()) {
        let p = f64::from(*x) * f64::from(*y);
        sum += p;
        abs_sum += p.abs();
    }
    (sum, abs_sum)
}

/// f64 ground truth for squared L2.
fn reference_squared_l2_f64(a: &[f32], b: &[f32]) -> (f64, f64) {
    let mut sum = 0.0_f64;
    for (x, y) in a.iter().zip(b.iter()) {
        let d = f64::from(*x) - f64::from(*y);
        sum += d * d;
    }
    // All terms are non-negative, so condition_number == sum
    (sum, sum)
}

/// f64 ground truth for cosine similarity.
fn reference_cosine_f64(a: &[f32], b: &[f32]) -> f64 {
    let (dot, _) = reference_dot_f64(a, b);
    let norm_a = a.iter().map(|x| f64::from(*x).powi(2)).sum::<f64>().sqrt();
    let norm_b = b.iter().map(|x| f64::from(*x).powi(2)).sum::<f64>().sqrt();
    if norm_a == 0.0 || norm_b == 0.0 { 0.0 } else { (dot / (norm_a * norm_b)).clamp(-1.0, 1.0) }
}

/// f64 ground truth for Hamming distance.
fn reference_hamming_f64(a: &[f32], b: &[f32]) -> f64 {
    a.iter().zip(b.iter())
        .filter(|(&x, &y)| (x > 0.5) != (y > 0.5))
        .count() as f64
}

/// f64 ground truth for Jaccard similarity.
fn reference_jaccard_f64(a: &[f32], b: &[f32]) -> (f64, f64) {
    let mut intersection = 0.0_f64;
    let mut union = 0.0_f64;
    for (x, y) in a.iter().zip(b.iter()) {
        let fx = f64::from(*x);
        let fy = f64::from(*y);
        intersection += fx.min(fy);
        union += fx.max(fy);
    }
    let result = if union == 0.0 { 1.0 } else { intersection / union };
    let condition = if union == 0.0 { 1.0 } else { intersection.abs() + union.abs() };
    (result, condition)
}
```

Keep the old f32 scalar functions for the `test_tolerance_matrix_sanity` test (they're used
for quick correctness checks on small vectors where precision isn't an issue).

**Verify:**
```powershell
cargo check --package velesdb-core --test simd_property_tests
```

**Done when:**
- All 5 f64 reference functions compile
- Old f32 scalar functions retained for sanity test

---

### Task 2: Implement Higham error bound helper

**Files:** `crates/velesdb-core/tests/simd_property_tests.rs`

**Action:**
Replace the fixed `Tolerance` struct with a dynamic bound function:

```rust
/// Higham's forward error bound for floating-point summation.
///
/// For a sum of N f32 terms computed in any order:
///   |error| ≤ γ(N) × condition_number
/// where γ(N) = N × u / (1 - N × u), u = f32::EPSILON / 2.
///
/// Reference: Higham, "Accuracy and Stability of Numerical Algorithms", 2002.
fn higham_bound(n: usize, condition_number: f64) -> f64 {
    let u = f64::from(f32::EPSILON) / 2.0;  // unit roundoff
    let n_f64 = n as f64;
    let gamma = n_f64 * u / (1.0 - n_f64 * u);
    // Floor at single-precision epsilon for degenerate cases (N=0, condition=0)
    (gamma * condition_number).max(f64::from(f32::EPSILON))
}
```

Remove the old `Tolerance` struct and the fixed `DOT_TOLERANCE`, `SQUARED_L2_TOLERANCE`,
`EUCLIDEAN_TOLERANCE`, `COSINE_TOLERANCE`, `JACCARD_TOLERANCE` constants.

**Verify:**
```powershell
cargo check --package velesdb-core --test simd_property_tests
```

**Done when:**
- `higham_bound` function exists with doc comment citing Higham
- Old fixed tolerance constants removed
- Old `Tolerance` struct removed (or kept only for `test_tolerance_matrix_sanity`)

---

### Task 3: Rewrite proptest cases to use f64 reference + Higham bound

**Files:** `crates/velesdb-core/tests/simd_property_tests.rs`

**Action:**
Rewrite each proptest case to:
1. Compute f64 reference + condition number
2. Compute f32 SIMD result
3. Compare `|f32_simd as f64 - f64_reference| ≤ higham_bound(N, condition)`

Example for dot product:
```rust
#[test]
fn test_dot_product_native_matches_f64_reference((a, b) in finite_vector_pair_strategy()) {
    let simd = f64::from(dot_product_native(&a, &b));
    let (reference, condition) = reference_dot_f64(&a, &b);
    let bound = higham_bound(a.len(), condition);
    prop_assert!(
        (simd - reference).abs() <= bound,
        "dot mismatch len={} simd={} ref={} delta={} bound={}",
        a.len(), simd, reference, (simd - reference).abs(), bound
    );
}
```

Apply same pattern to squared_l2, euclidean, cosine, hamming, jaccard.

For **cosine**: the error bound is more complex (ratio of sums). Use a conservative
approach: `3 × higham_bound(N, norm_condition)` to account for the division and sqrt
operations in normalization. If this is too tight, derive the exact bound for the
cosine formula `dot / (|a| × |b|)`.

For **hamming**: exact integer arithmetic — tolerance is 0 (no f32 accumulation).
Keep `prop_assert_eq!` for hamming.

**Verify:**
```powershell
cargo test --package velesdb-core --test simd_property_tests -- --nocapture
```

**Done when:**
- All 6 proptest cases rewritten with f64 reference + Higham bound
- All pass on first run

---

### Task 4: Update `test_tolerance_matrix_sanity` and `assert_close`

**Files:** `crates/velesdb-core/tests/simd_property_tests.rs`

**Action:**
Update `test_tolerance_matrix_sanity` to use the new f64 references and Higham bound.
The `assert_close` helper can be kept for this sanity test but should use the dynamic bound.

**Verify:**
```powershell
cargo test --package velesdb-core --test simd_property_tests test_tolerance_matrix_sanity -- --nocapture
```

**Done when:**
- Sanity test passes with new bound system

---

### Task 5: Stability verification — 10 consecutive runs

**Files:** None (verification only)

**Action:**
Run the full proptest suite 10 times to confirm zero flaky failures.

**Verify:**
```powershell
for ($i = 1; $i -le 10; $i++) { Write-Host "Run $i"; cargo test --package velesdb-core --test simd_property_tests 2>&1 | Select-String "test result" }
```

**Done when:**
- 10/10 runs pass with 0 failures

---

## Verification

After all tasks complete:

```powershell
cargo test --package velesdb-core --test simd_property_tests
cargo clippy --package velesdb-core -- -D warnings
cargo test --package velesdb-core simd_native -- --nocapture 2>&1 | Select-String "test result"
```

## Success Criteria

- [ ] All scalar references use f64 accumulation (proper ground truth)
- [ ] Tolerances use Higham's `γ(N) × condition_number` bound (no arbitrary constants)
- [ ] `higham_bound()` function has doc comment citing Higham 2002
- [ ] All 6 proptest cases pass 10/10 consecutive runs
- [ ] No regressions in SIMD unit tests
- [ ] `cargo clippy -- -D warnings` clean

## Output

**Files modified:**
- `crates/velesdb-core/tests/simd_property_tests.rs` — f64 references, Higham bound, rewritten proptests
