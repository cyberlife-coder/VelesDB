---
phase: 2
plan: 2
name: Wire Subquery into MATCH WHERE Path
wave: 2
depends_on: ["02-01"]
autonomous: true
---

# Phase 2 Plan 2: Wire Subquery into MATCH WHERE Path

## Objective

Connect the scalar subquery executor (from Plan 02-01) into the MATCH WHERE evaluation path so that `Value::Subquery` in comparison conditions is resolved at runtime instead of being ignored. This fixes all MATCH queries that use subqueries in their WHERE clause.

## Context

**Requirements addressed:** VP-002
**Phase goal contribution:** Makes MATCH WHERE subqueries functional — the primary path used by all 4 README business scenarios.

**Current state:**
- `where_eval.rs::resolve_where_param()` (line 235) passes `Value::Subquery` through unchanged via `other => Ok(other.clone())`
- `where_eval.rs::evaluate_comparison()` (line 296) returns `Ok(false)` for type mismatch when comparing payload value vs `Value::Subquery`
- Net effect: any MATCH WHERE with a subquery comparison silently returns **no results** (false for every node)

**Target state:**
- `resolve_where_param` detects `Value::Subquery` and calls `self.resolve_value()` to execute it
- The resolved concrete `Value` (Integer, Float, String, etc.) is then compared normally
- BETWEEN and IN conditions also resolve subquery values in their bounds/lists

## Tasks

### Task 1: Write failing integration tests for subquery in MATCH WHERE (RED)

**Files:** `crates/velesdb-core/src/collection/search/query/match_where_eval_tests.rs`

**Action:**
Add new tests to the existing `match_where_eval_tests.rs` file:

1. **test_match_where_comparison_with_subquery** — MATCH query where a comparison value is a subquery:
   ```
   MATCH (p:Product) WHERE p.price < (SELECT AVG(price) FROM products)
   ```
   Setup: Create collection with products at various prices. The subquery should resolve to the average, and only products below average should match.

2. **test_match_where_subquery_no_results** — Subquery returns no rows → comparison value is Null → node doesn't match.

3. **test_match_where_between_with_subquery** — BETWEEN where one bound is a subquery (if AST supports it — verify first, may be deferred).

These tests should fail initially because `resolve_where_param` doesn't handle subqueries yet.

**Verify:**
```powershell
cargo test -p velesdb-core --lib match_where_eval_tests::test_match_where_comparison_with_subquery 2>&1 | Select-Object -Last 5
# Should FAIL (RED phase)
```

**Done when:**
- New tests compile and fail with incorrect results (subquery not executed)

---

### Task 2: Modify `resolve_where_param` to execute subqueries

**Files:** `crates/velesdb-core/src/collection/search/query/match_exec/where_eval.rs`

**Action:**
The key challenge: `resolve_where_param` is currently a **static method** (`fn resolve_where_param(value, params)`) without `&self`. It needs access to `&self` (Collection) to execute subqueries.

Two approaches:
- **Option A (Preferred):** Change `resolve_where_param` to take an optional `&Collection` parameter for subquery resolution. Keep backward compat by resolving subquery only when collection ref is provided.
- **Option B:** Resolve subqueries earlier, before calling `evaluate_where_condition`, by walking the condition tree and replacing `Value::Subquery` with resolved values.

**Recommended: Option A** — Minimal change, targeted fix.

Modify `resolve_where_param` signature:
```rust
pub(crate) fn resolve_where_param(
    value: &crate::velesql::Value,
    params: &HashMap<String, serde_json::Value>,
    collection: Option<&Collection>,  // VP-002: For subquery execution
    outer_row: Option<&serde_json::Value>,  // VP-002: For correlated subqueries
) -> Result<crate::velesql::Value>
```

Add the `Value::Subquery` arm:
```rust
Value::Subquery(sub) => {
    let coll = collection.ok_or_else(|| Error::UnsupportedFeature(
        "Subqueries require collection context".to_string()
    ))?;
    coll.resolve_value(value, params, outer_row)
}
```

Update all call sites of `resolve_where_param` to pass `Some(self)` and the appropriate `outer_row`.

For the `evaluate_where_condition` Comparison branch, the outer_row context comes from the node's payload:
```rust
let payload_for_outer = payload_storage.retrieve(node_id).ok().flatten();
let resolved_value = Self::resolve_where_param(
    &cmp.value, params, Some(self), payload_for_outer.as_ref()
)?;
```

**Verify:**
```powershell
cargo test -p velesdb-core --lib match_where_eval_tests 2>&1 | Select-Object -Last 10
# All tests should pass (GREEN phase)
```

**Done when:**
- `resolve_where_param` executes subqueries via `Collection::resolve_value()`
- All existing MATCH WHERE tests still pass (no regression)
- New subquery-in-MATCH-WHERE tests pass
- Correlated subqueries use node payload as outer row context

---

### Task 3: Handle subqueries in BETWEEN/IN value positions

**Files:** `crates/velesdb-core/src/collection/search/query/match_exec/where_eval.rs`

**Action:**
Check if `evaluate_between_condition` and `evaluate_in_condition` can encounter `Value::Subquery` in their value positions (low/high bounds, IN list values).

If yes (parser allows subquery in these positions), resolve them before comparison:
- In `evaluate_between_condition`: resolve `btw.low` and `btw.high` through `resolve_value`
- In `evaluate_in_condition`: resolve each value in `inc.values` through `resolve_value`

If no (parser doesn't produce subqueries in these positions), add a comment documenting this.

**Verify:**
```powershell
cargo test -p velesdb-core --lib match_where_eval_tests 2>&1 | Select-Object -Last 5
cargo clippy -p velesdb-core -- -D warnings 2>&1 | Select-Object -Last 5
```

**Done when:**
- BETWEEN/IN with subquery values either work or are explicitly documented as unsupported
- No clippy warnings

---

## Verification

After all tasks complete:

```powershell
cargo fmt --all --check
cargo clippy -p velesdb-core -- -D warnings
cargo test -p velesdb-core --lib match_where_eval_tests
cargo test -p velesdb-core --lib subquery_tests
cargo test -p velesdb-core --lib match_exec_tests
```

## Success Criteria

- [ ] `Value::Subquery` in MATCH WHERE Comparison is executed and resolved to concrete value
- [ ] Correlated subqueries use node payload as outer row context
- [ ] Empty subquery results → `Value::Null` → comparison returns false (not silent pass)
- [ ] All existing MATCH WHERE tests still pass (no regression)
- [ ] At least 2 new integration tests for subquery in MATCH WHERE
- [ ] No clippy warnings

## Output

**Files modified:**
- `crates/velesdb-core/src/collection/search/query/match_exec/where_eval.rs` — Subquery resolution in `resolve_where_param`
- `crates/velesdb-core/src/collection/search/query/match_where_eval_tests.rs` — New integration tests
