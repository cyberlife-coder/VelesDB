---
phase: 4
plan: 5
name: Complex MATCH Business Scenarios
wave: 2
depends_on: [04-01]
autonomous: true
parallel_safe: true
---

# Phase 4 Plan 05: Complex MATCH Business Scenarios

## Objective

Implement E2E tests for Business Scenario 2 (Fraud Detection) and Business Scenario 3 (Healthcare Diagnosis). These use advanced MATCH patterns: multi-hop traversal with variable-length paths, subquery execution, and RETURN aggregation (COUNT, AVG).

## Context

**Requirements addressed:** VP-007
**Phase goal contribution:** Validates the most complex MATCH query patterns from the README. These scenarios combine multi-hop graph traversal (VP-004), subquery execution (VP-002), and RETURN aggregation (VP-005) — features implemented in Phases 1-3.

## Tasks

### Task 1: Implement Business Scenario 2 — Fraud Detection

**Files:** `tests/readme_scenarios/match_complex.rs`

**Action:**
Test the README query pattern:
```sql
MATCH (tx:Transaction)-[:FROM]->(account:Account)-[:LINKED_TO*1..3]->(related:Account)
WHERE 
  similarity(tx.behavior_embedding, $known_fraud_pattern) > 0.6
  AND related.risk_level = 'high'
  AND (SELECT SUM(amount) FROM transactions 
       WHERE account_id = account.id 
       AND timestamp > NOW() - INTERVAL '24 hours') > 10000
RETURN tx.id, account.id, similarity() as fraud_score
```

**Simplified test** (subquery velocity check deferred to Plan 04-06):
```
MATCH (tx:Transaction)-[:FROM]->(account:Account)-[:LINKED_TO]->(related:Account)
WHERE related.risk_level = 'high'
RETURN tx.id, account.id
```

Implementation:
1. Create collection (dim=4, cosine)
2. Insert Transaction nodes with `_labels: ["Transaction"]`, `amount`, `behavior_embedding` (as vector)
3. Insert Account nodes with `_labels: ["Account"]`, `risk_level` ('high', 'medium', 'low'), `account_id`
4. Add edges:
   - `FROM` (Transaction → Account)
   - `LINKED_TO` (Account → Account) forming a network
5. Build multi-hop `MatchClause`:
   - Pattern: `(tx:Transaction)-[:FROM]->(account:Account)-[:LINKED_TO]->(related:Account)`
   - WHERE: `related.risk_level = 'high'` (binding-aware)
   - RETURN: `tx.id, account.id`
6. Execute and assert:
   - Multi-hop traversal (2 hops: Transaction→Account→related Account)
   - Only paths ending at high-risk related accounts returned
   - Bindings contain tx, account, related aliases
   - Correct number of results for the test graph structure

**Verify:**
```powershell
cargo test --test readme_scenarios match_complex::test_bs2_fraud_detection -- --nocapture
```

**Done when:**
- 2-hop MATCH traversal works: Transaction→Account→RelatedAccount
- Binding-aware WHERE filters on final hop node (related.risk_level)
- All 3 node aliases populated in results
- Test graph structure produces expected number of fraud paths

---

### Task 2: Implement Business Scenario 3 — Healthcare Diagnosis

**Files:** `tests/readme_scenarios/match_complex.rs`

**Action:**
Test the README query pattern:
```sql
MATCH (patient:Patient)-[:HAS_CONDITION]->(condition:Condition)
      -[:TREATED_WITH]->(treatment:Treatment)
WHERE 
  similarity(condition.symptoms_embedding, $current_symptoms) > 0.75
  AND condition.icd10_code IN ('J18.9', 'J12.89')
RETURN treatment.name, AVG(success_rate) as effectiveness
```

Implementation:
1. Create collection (dim=4, cosine)
2. Insert Patient nodes with `_labels: ["Patient"]`
3. Insert Condition nodes with `_labels: ["Condition"]`, `icd10_code`, `symptoms_embedding` (as vector)
4. Insert Treatment nodes with `_labels: ["Treatment"]`, `name`, `success_rate` (float)
5. Add edges:
   - `HAS_CONDITION` (Patient → Condition)
   - `TREATED_WITH` (Condition → Treatment)
6. Build multi-hop `MatchClause`:
   - Pattern: `(patient:Patient)-[:HAS_CONDITION]->(condition:Condition)-[:TREATED_WITH]->(treatment:Treatment)`
   - WHERE: `condition.icd10_code IN ('J18.9', 'J12.89')` (binding-aware)
   - RETURN: `treatment.name, AVG(treatment.success_rate)` — triggers aggregation (VP-005)
7. Execute and assert:
   - 2-hop traversal: Patient→Condition→Treatment
   - IN condition filters on intermediate node (icd10_code)
   - RETURN aggregation produces grouped results with AVG
   - Treatment names and average success rates are correct

**Verify:**
```powershell
cargo test --test readme_scenarios match_complex::test_bs3_healthcare -- --nocapture
```

**Done when:**
- 2-hop MATCH traversal: Patient→Condition→Treatment
- IN condition on intermediate node works (binding-aware)
- RETURN with AVG aggregation computes correct averages
- Results grouped by non-aggregated RETURN items (treatment.name)

---

### Task 3: Variable-length path regression test

**Files:** `tests/readme_scenarios/match_complex.rs`

**Action:**
Test the fraud detection variant with variable-length paths:
```sql
MATCH (tx:Transaction)-[:FROM]->(account:Account)-[:LINKED_TO*1..3]->(related:Account)
```

Implementation:
1. Reuse the fraud detection graph from Task 1
2. Build MatchClause with variable-length relationship: `range = Some((1, 3))`
3. Execute and assert:
   - Results include accounts at depth 1, 2, and 3
   - More results than single-hop version (depth 1 only)
   - No infinite loops or panics

**Verify:**
```powershell
cargo test --test readme_scenarios match_complex::test_variable_length_fraud -- --nocapture
```

**Done when:**
- Variable-length path `*1..3` produces results at multiple depths
- Results count > single-hop results count
- No panics or timeouts

---

## Verification

After all tasks complete:

```powershell
cargo test --test readme_scenarios match_complex -- --nocapture
cargo clippy --test readme_scenarios -- -D warnings
```

## Success Criteria

- [ ] BS2 Fraud: 2-hop MATCH with binding-aware WHERE on final node
- [ ] BS3 Healthcare: 2-hop MATCH with IN on intermediate node + RETURN AVG aggregation
- [ ] Variable-length paths produce multi-depth results
- [ ] All node aliases correctly populated in bindings
- [ ] Aggregation results are numerically correct
- [ ] Tests use realistic data matching README descriptions

## Parallel Safety

**Exclusive write files:** `tests/readme_scenarios/match_complex.rs`
**Shared read files:** `tests/readme_scenarios/helpers.rs` (read), `crates/velesdb-core/src/**` (read)
**Conflicts with:** none (unique write file)

## Output

**Files modified:**
- `tests/readme_scenarios/match_complex.rs` — Replaces stub with 3 complex MATCH scenario tests
