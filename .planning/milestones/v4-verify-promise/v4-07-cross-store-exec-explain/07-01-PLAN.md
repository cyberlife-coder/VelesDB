# Plan 07-01: Cross-Store VectorFirst & Parallel Execution

## Objective

Wire `QueryPlanner` into `execute_query()` and implement VectorFirst and Parallel cross-store execution strategies for combined NEAR + graph MATCH queries.

**Estimate:** 4-6h
**Wave:** 1 (sequential)

---

## Context

### Current State
- **GraphFirst** exists: `execute_match_with_similarity()` traverses graph first, then scores vectors
- **QueryPlanner** exists in `planner.rs` with `choose_hybrid_strategy()` but is never called
- **VectorFirst** (vector search → graph validate) is NOT implemented
- **Parallel** (both → fuse with RRF) is NOT implemented
- `execute_query()` ignores `query.match_clause` entirely — graph MATCH goes through separate `execute_match()` entry point
- `hybrid.rs` fusion functions are re-exported and available: `fuse_rrf`, `fuse_weighted`, `fuse_maximum`, `intersect_results`

### Target State
- `execute_query()` detects combined SELECT WHERE NEAR + MATCH clause
- `QueryPlanner::choose_hybrid_strategy()` picks optimal strategy
- VectorFirst: NEAR search (over-fetch) → filter candidates against graph MATCH pattern → apply column filters
- Parallel: execute vector search + graph MATCH concurrently → fuse results with RRF
- GraphFirst: delegates to existing `execute_match_with_similarity()`
- Results unified as `Vec<SearchResult>`

---

## Tasks

### Task 1: TDD — Write cross-store execution tests

**Files:** `crates/velesdb-core/src/collection/search/query/cross_store_exec_tests.rs`

**Action:**
1. Create test file with tests for:
   - `test_vector_first_returns_graph_validated_results` — NEAR search then graph validate
   - `test_vector_first_respects_limit` — over-fetch + filter + truncate
   - `test_vector_first_with_metadata_filter` — three-way: V + G + metadata
   - `test_parallel_fuses_results` — concurrent V+G with RRF fusion
   - `test_parallel_respects_limit` — limit after fusion
   - `test_planner_wired_in_execute_query` — verify planner is called for combined queries
   - `test_graph_first_delegates_to_existing` — fallback to `execute_match_with_similarity()`
   - `test_cross_store_no_graph_match_unchanged` — pure NEAR queries unaffected
2. Register test module in `mod.rs`

**Verify:** `cargo test cross_store_exec_tests -- --no-run`

**Done:** Test file created, module registered

### Task 2: Create cross_store_exec.rs module

**Files:** `crates/velesdb-core/src/collection/search/query/cross_store_exec.rs` (new)

**Action:**
1. Create module with:
   - `execute_vector_first_cross_store()`:
     - Execute vector NEAR search with over-fetch (limit × `plan.over_fetch_factor`)
     - For each candidate, validate against graph MATCH pattern using `find_start_nodes()` + relationship check
     - Apply column metadata filters
     - Return merged results sorted by vector score
   - `execute_parallel_cross_store()`:
     - Execute vector search to get `Vec<SearchResult>`
     - Execute graph MATCH to get `Vec<MatchResult>`
     - Convert MatchResults to ScoredResults via `match_results_to_search_results()`
     - Fuse with `fuse_rrf()` from `hybrid.rs`
     - Apply post-fusion column filters
     - Return fused results
2. Use `match_exec` infrastructure for graph validation
3. Use `filter::Filter` for column filtering
4. Keep module under 300 lines

**Verify:** `cargo check --package velesdb-core`

**Done:** Module compiles, strategies implemented

### Task 3: Wire QueryPlanner into execute_query()

**Files:** `crates/velesdb-core/src/collection/search/query/mod.rs`, `dispatch.rs`

**Action:**
1. In `execute_query()`, after extracting conditions, check `query.match_clause.is_some()`:
   - If both vector search AND match_clause present → cross-store path
   - Call `QueryPlanner::choose_hybrid_strategy()` with:
     - `has_order_by_similarity`: check `stmt.order_by` for similarity()
     - `has_filter`: check for metadata filters
     - `limit`: from stmt
     - `estimated_selectivity`: from planner heuristics
   - Route to appropriate strategy in `cross_store_exec.rs`
2. Add `dispatch_cross_store()` in `dispatch.rs`:
   - Takes `HybridExecutionPlan` + query context
   - Routes to VectorFirst, GraphFirst, or Parallel
3. GraphFirst → delegate to existing `execute_match_with_similarity()` + `match_results_to_search_results()`
4. Ensure `mod.rs` stays under 300 lines

**Verify:** `cargo test cross_store_exec_tests && cargo clippy -- -D warnings`

**Done:** QueryPlanner wired, all strategies routed correctly

### Task 4: Integration and edge cases

**Files:** Various

**Action:**
1. Handle edge case: empty graph (no edges) → VectorFirst degrades to pure NEAR
2. Handle edge case: no vector search in combined query → GraphFirst only
3. Verify no regressions on existing 3,234 tests
4. Run clippy, fmt

**Verify:** `cargo test --workspace && cargo clippy -- -D warnings && cargo fmt --all --check`

**Done:** All quality gates pass

---

## Key Files

| File | Role |
|------|------|
| `collection/search/query/cross_store_exec.rs` | New — VectorFirst + Parallel execution |
| `collection/search/query/cross_store_exec_tests.rs` | New — TDD tests |
| `collection/search/query/mod.rs` | Wire combined V+G detection |
| `collection/search/query/dispatch.rs` | Add `dispatch_cross_store()` |
| `velesql/planner.rs` | `choose_hybrid_strategy()` — already exists |
| `velesql/hybrid.rs` | `fuse_rrf()` — already exists, re-exported |
| `collection/search/query/match_exec/similarity.rs` | `execute_match_with_similarity()` — GraphFirst fallback |

## Success Criteria

- [ ] VectorFirst: NEAR → graph validate → filter → results
- [ ] Parallel: concurrent V+G → fuse RRF → filter → results
- [ ] GraphFirst: delegates to `execute_match_with_similarity()`
- [ ] `QueryPlanner::choose_hybrid_strategy()` called for combined V+G queries
- [ ] 8+ new tests pass
- [ ] `mod.rs` stays under 300 lines
- [ ] No regressions on existing tests
