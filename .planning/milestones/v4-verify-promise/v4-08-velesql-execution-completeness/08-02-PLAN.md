# Plan 08-02: JOIN Execution Integration

**Phase:** 8 — VelesQL Execution Completeness
**Requirement:** VP-014
**Estimate:** 4-5h
**Depends on:** Plan 08-01 (Database executor + ColumnStore builder)

---

## Goal

Wire `stmt.joins` into the query execution pipeline so that JOIN clauses actually execute. Implement INNER JOIN (existing logic) and LEFT JOIN (new) via the Database-level executor.

---

## Tasks

### Task 1: Remove dead_code from join.rs

**File:** `crates/velesdb-core/src/collection/search/query/join.rs`

- Remove `#![allow(dead_code)]` at line 9
- Verify all functions compile without the allow

### Task 2: Implement LEFT JOIN in execute_join (TDD)

**File:** `crates/velesdb-core/src/collection/search/query/join.rs`

Current `execute_join()` only implements INNER JOIN behavior (skips non-matching rows). Add LEFT JOIN support:

```rust
/// Executes a JOIN between search results and a ColumnStore.
///
/// Supports INNER and LEFT join types. RIGHT and FULL planned for future.
pub fn execute_join(
    results: &[SearchResult],
    join: &JoinClause,
    column_store: &ColumnStore,
) -> Vec<JoinedResult>
```

**LEFT JOIN behavior:**
- All left-side results are kept
- Non-matching rows get empty `column_data: HashMap::new()`
- Matching rows get merged column data (same as INNER)

**Tests (RED first):**
- `test_left_join_keeps_all_left_rows` — non-matching left rows included with empty columns
- `test_left_join_merges_matching_rows` — matching rows have column data
- `test_inner_join_filters_non_matching` — existing behavior preserved
- `test_right_join_returns_error` — unsupported type returns clear error
- `test_full_join_returns_error` — unsupported type returns clear error

### Task 3: Wire JOIN into Database::execute_query() (TDD)

**File:** `crates/velesdb-core/src/lib.rs` (or `database_query.rs`)

Replace the JOIN stub from Plan 08-01 with actual execution:

```rust
// After collection.execute_query() returns base results:
if !stmt.joins.is_empty() {
    for join_clause in &stmt.joins {
        // 1. Resolve JOIN table as a collection
        let join_collection = self.get_collection(&join_clause.table)
            .ok_or_else(|| Error::CollectionNotFound(join_clause.table.clone()))?;
        
        // 2. Build ColumnStore from JOIN collection
        let column_store = column_store_from_collection(&join_collection, MAX_JOIN_ROWS)?;
        
        // 3. Execute JOIN
        let joined = join::execute_join(&results, join_clause, &column_store);
        
        // 4. Convert back to SearchResults
        results = join::joined_to_search_results(joined);
    }
}
```

**Tests (RED first):**
- `test_database_join_two_collections` — basic INNER JOIN across collections
- `test_database_join_collection_not_found` — returns Error::CollectionNotFound for JOIN table
- `test_database_left_join` — LEFT JOIN keeps all left rows
- `test_database_join_with_where_filter` — WHERE applied before JOIN
- `test_database_join_with_order_by` — ORDER BY applied after JOIN
- `test_database_multiple_joins` — chained JOINs work sequentially
- `test_database_join_with_vector_search` — NEAR + JOIN works

### Task 4: Quality Gates

```powershell
cargo fmt --all --check
cargo clippy -- -D warnings
cargo test --workspace
cargo build --release
```

---

## Acceptance Criteria

- [ ] `#![allow(dead_code)]` removed from join.rs
- [ ] LEFT JOIN implemented with proper semantics
- [ ] INNER JOIN preserves existing behavior
- [ ] RIGHT/FULL JOIN return clear unsupported error
- [ ] Database executor applies JOINs after base query
- [ ] Multi-JOIN (chained) works correctly
- [ ] Error on non-existent JOIN table
- [ ] All quality gates pass
- [ ] 12+ new tests

---

## Files

| File | Action |
|------|--------|
| `src/collection/search/query/join.rs` | **Modify** — remove dead_code, add LEFT JOIN |
| `src/collection/search/query/join_tests.rs` | **Modify** — add LEFT JOIN tests |
| `src/lib.rs` (or `database_query.rs`) | **Modify** — wire JOIN into Database executor |

---
*Created: 2026-02-09*
