---
phase: v4-01
plan: 2
name: Wire Temporal resolution into MATCH WHERE comparison
wave: 1
depends_on: none
autonomous: true
parallel_safe: true
---

# Phase v4-01 Plan 02: Wire Temporal Resolution into MATCH WHERE Comparison

## Objective

Fix `Value::Temporal` handling in MATCH WHERE so that temporal expressions like `NOW() - INTERVAL '7 days'` are resolved to epoch integers before comparison. Currently `resolve_where_param` passes `Temporal` through unchanged, and `evaluate_comparison` silently returns `false` for `(Number, Temporal)` pairs.

## Context

**Requirements addressed:** VP-003
**Phase goal contribution:** Completes temporal comparison support in MATCH WHERE, matching the SELECT path behavior.

**Root cause:** The SELECT path (`filter/conversion.rs:19-21`) converts `Value::Temporal(t)` → `Value::Number(t.to_epoch_seconds())`. But the MATCH WHERE path (`where_eval.rs:resolve_where_param:236`) passes `Temporal` through unchanged via `other => Ok(other.clone())`. Then `evaluate_comparison:297` hits `_ => Ok(false)` for `(Number, Temporal)` — **silently rejecting all temporal comparisons**.

**Reference fix in SELECT path:**
```rust
// filter/conversion.rs:19-21
crate::velesql::Value::Temporal(t) => {
    Value::Number(t.to_epoch_seconds().into())
}
```

## Tasks

### Task 1: Resolve `Value::Temporal` in `resolve_where_param`

**Files:** `crates/velesdb-core/src/collection/search/query/match_exec/where_eval.rs`

**Action:**
In `resolve_where_param` (line ~236), add a `Value::Temporal` arm before the catch-all:

```rust
Value::Temporal(t) => {
    // VP-003: Resolve temporal expression to epoch seconds for comparison
    Ok(Value::Integer(t.to_epoch_seconds()))
}
```

This converts `NOW()`, `NOW() - INTERVAL '7 days'`, etc. to integer epoch seconds, matching the SELECT path behavior.

**Verify:**
```powershell
cargo check -p velesdb-core
```

**Done when:**
- `Value::Temporal` resolves to `Value::Integer(epoch)` in MATCH WHERE
- Existing integer comparison logic handles the rest

---

### Task 2: Add unit test for temporal comparison in MATCH WHERE

**Files:** `crates/velesdb-core/src/collection/search/query/match_where_eval_tests.rs`

**Action:**
Add a test that uses `Value::Temporal(TemporalExpr::Now)` in a comparison and verifies it actually filters:

```rust
#[test]
fn test_match_where_temporal_now_resolves() {
    let (_dir, collection) = setup_match_test_collection();

    // updated_at > NOW() should return 0 results (test data timestamps are in the past)
    let condition = Condition::Comparison(Comparison {
        column: "updated_at".to_string(),
        operator: CompareOp::Gt,
        value: Value::Temporal(TemporalExpr::Now),
    });

    let clause = match_clause_with_condition(condition);
    let results = collection
        .execute_match(&clause, &HashMap::new())
        .expect("execute_match failed");

    // All test nodes have timestamps ~1700000000 which is in the past
    assert_eq!(results.len(), 0, "No nodes should have updated_at > NOW()");
}

#[test]
fn test_match_where_temporal_subtract_resolves() {
    let (_dir, collection) = setup_match_test_collection();

    // updated_at > NOW() - INTERVAL '999999 days' should return all nodes
    // (a date very far in the past)
    let condition = Condition::Comparison(Comparison {
        column: "updated_at".to_string(),
        operator: CompareOp::Gt,
        value: Value::Temporal(TemporalExpr::Subtract(
            Box::new(TemporalExpr::Now),
            Box::new(TemporalExpr::Interval(IntervalValue {
                magnitude: 999999,
                unit: IntervalUnit::Days,
            })),
        )),
    });

    let clause = match_clause_with_condition(condition);
    let results = collection
        .execute_match(&clause, &HashMap::new())
        .expect("execute_match failed");

    assert_eq!(results.len(), 4, "All 4 nodes should be after a very old date");
}
```

**Verify:**
```powershell
cargo test -p velesdb-core --lib -- match_where_eval_tests::test_match_where_temporal -- --nocapture
```

**Done when:**
- `test_match_where_temporal_now_resolves` passes (0 results — all timestamps in past)
- `test_match_where_temporal_subtract_resolves` passes (4 results — all timestamps after ancient date)
- Proves temporal values are resolved, not silently dropped

---

### Task 3: Verify binding-aware path also resolves temporal

**Files:** `crates/velesdb-core/src/collection/search/query/match_exec/where_eval.rs`

**Action:**
Verify that `evaluate_where_with_bindings` (the multi-hop path) also calls `resolve_where_param` for comparison values. Check line ~360:

```rust
let pre_resolved = self.resolve_subquery_value(&cmp.value, params, None)?;
let resolved_value = Self::resolve_where_param(&pre_resolved, params)?;
```

If this is present → Task 1's fix automatically covers binding-aware path too. If not, add the same `resolve_where_param` call.

Document the finding — no code change needed if already present.

**Verify:**
```powershell
cargo test --test readme_scenarios match_simple::test_bs4 -- --nocapture
```

**Done when:**
- Binding-aware path confirmed to use `resolve_where_param` (already present at line 360-361)
- BS4 temporal filter tests pass (they use `Value::Integer` which already works, confirming the path)

---

## Verification

After all tasks complete:

```powershell
cargo test -p velesdb-core --lib -- match_where_eval_tests -- --nocapture
cargo test --test readme_scenarios match_simple -- --nocapture
cargo clippy -p velesdb-core -- -D warnings
```

## Success Criteria

- [ ] `Value::Temporal(NOW())` resolves to epoch integer in MATCH WHERE comparisons
- [ ] `Value::Temporal(NOW() - INTERVAL)` resolves correctly
- [ ] Unit tests prove temporal values are not silently dropped
- [ ] Binding-aware WHERE path also resolves temporal (verified)
- [ ] Clippy clean

## Parallel Safety

**Exclusive write files:**
- `crates/velesdb-core/src/collection/search/query/match_exec/where_eval.rs`
- `crates/velesdb-core/src/collection/search/query/match_where_eval_tests.rs`

**Shared read files:** condition.rs, values.rs
**Conflicts with:** Plan 01 does NOT touch these files → safe to parallel
