---
phase: 3
plan: 2
name: RETURN Aggregation for MATCH Results
wave: 2
depends_on: ["03-01"]
autonomous: true
---

# Phase 3 Plan 2: RETURN Aggregation for MATCH Results

## Objective

Add aggregation support to the MATCH RETURN clause so that expressions like `RETURN author.name, COUNT(*), AVG(rating)` compute aggregations over match results with implicit grouping. This closes VP-005.

## Context

**Requirements addressed:** VP-005
**Phase goal contribution:** Makes Healthcare scenario (`RETURN treatment.name, AVG(success_rate)`) and Technical deep-dive aggregation queries functional.

**Current state:**
- `project_properties()` in `similarity.rs` handles property paths like `author.name` via `parse_property_path()`
- `ReturnItem.expression` is a raw string — `"COUNT(*)"`, `"AVG(success_rate)"` are stored as-is
- No detection of aggregation functions in RETURN items
- The aggregation engine exists in `aggregation/mod.rs` for SELECT queries but is completely separate from MATCH
- `parse_return_expr()` in `match_parser.rs` returns the text without parsing aggregation functions

**Target state:**
- RETURN items containing aggregation functions (COUNT, AVG, SUM, MIN, MAX) are detected
- Non-aggregated items become implicit grouping keys (OpenCypher standard)
- Aggregations are computed over the grouped match result sets
- If no aggregation in RETURN → current behavior unchanged (property projection only)

**Research validation:**
- OpenCypher spec: non-aggregated columns in RETURN become implicit grouping keys
- Neo4j Cypher Manual: `RETURN n.name, COUNT(*), AVG(n.age)` groups by `n.name`
- Apache AGE: same implicit grouping semantics for MATCH RETURN

## Tasks

### Task 1: Write failing tests for RETURN aggregation (RED)

**Files:** `crates/velesdb-core/src/collection/search/query/match_return_agg_tests.rs`

**Action:**
Create a new test file for MATCH RETURN aggregation tests. Setup: create a collection with:

```
Doctor:DrSmith  --[:TREATS]--> Patient:P1 {condition: 'flu', success_rate: 0.95}
Doctor:DrSmith  --[:TREATS]--> Patient:P2 {condition: 'flu', success_rate: 0.85}
Doctor:DrSmith  --[:TREATS]--> Patient:P3 {condition: 'cold', success_rate: 0.90}
Doctor:DrJones  --[:TREATS]--> Patient:P4 {condition: 'flu', success_rate: 0.80}
```

Tests:
1. **test_return_count_star** — `MATCH (d:Doctor)-[:TREATS]->(p:Patient) RETURN d.name, COUNT(*)`
   - DrSmith: 3, DrJones: 1

2. **test_return_avg_aggregation** — `MATCH (d:Doctor)-[:TREATS]->(p:Patient) RETURN d.name, AVG(p.success_rate)`
   - DrSmith: (0.95+0.85+0.90)/3 = 0.9, DrJones: 0.80

3. **test_return_without_aggregation_unchanged** — `MATCH (d:Doctor)-[:TREATS]->(p:Patient) RETURN d.name, p.condition`
   - Should return individual rows (no grouping) — regression test

4. **test_return_count_with_no_grouping_key** — `MATCH (d:Doctor)-[:TREATS]->(p:Patient) RETURN COUNT(*)`
   - Should return single row: 4

5. **test_return_aggregation_with_alias** — `RETURN d.name, COUNT(*) AS patient_count`
   - Verify alias is used as the result key

Register module in `mod.rs`: `#[cfg(test)] mod match_return_agg_tests;`

**Verify:**
```powershell
cargo test -p velesdb-core --lib match_return_agg_tests 2>&1 | Select-Object -Last 5
# Should FAIL (RED phase)
```

**Done when:**
- Tests compile and fail (aggregation not computed, returns raw expression strings)

---

### Task 2: Implement aggregation detection and computation in MATCH RETURN

**Files:**
- `crates/velesdb-core/src/collection/search/query/match_exec/return_agg.rs` (new)
- `crates/velesdb-core/src/collection/search/query/match_exec/mod.rs`

**Action:**
Create a new module `return_agg.rs` that adds aggregation support to MATCH results.

**Step 2a: Detect aggregation in RETURN items**

Add a helper to detect if a `ReturnItem.expression` contains an aggregation function:

```rust
/// Checks if a RETURN expression is an aggregation function.
/// Returns Some((agg_type, column)) if it is, None otherwise.
fn parse_return_aggregation(expression: &str) -> Option<(AggregateType, String)>
```

Supported patterns:
- `COUNT(*)` → (Count, "*")
- `COUNT(p.name)` → (Count, "p.name")
- `AVG(p.success_rate)` → (Avg, "p.success_rate")
- `SUM(p.amount)` → (Sum, "p.amount")
- `MIN(p.score)` → (Min, "p.score")
- `MAX(p.score)` → (Max, "p.score")

Case-insensitive matching. Trim whitespace inside parens.

**Step 2b: Classify RETURN items**

```rust
/// Classifies RETURN items into grouping keys and aggregations.
fn classify_return_items(items: &[ReturnItem]) -> (Vec<&ReturnItem>, Vec<ReturnAggregation>)
```

Where `ReturnAggregation` is:
```rust
struct ReturnAggregation {
    agg_type: AggregateType,
    column: String,       // e.g., "p.success_rate"
    result_key: String,   // alias or generated name like "avg_success_rate"
}
```

Non-aggregation items become grouping keys (OpenCypher implicit grouping).

**Step 2c: Compute aggregations over MatchResults**

Add a method to `impl Collection`:
```rust
pub(crate) fn aggregate_match_results(
    &self,
    results: &[MatchResult],
    return_clause: &ReturnClause,
) -> Option<Vec<MatchResult>>
```

Returns `None` if no aggregation detected (caller uses normal projection).
Returns `Some(aggregated_results)` if aggregation is present.

Algorithm:
1. Classify RETURN items → grouping keys + aggregations
2. If no aggregations → return None (no change)
3. Group results by grouping key values (using projected properties)
4. For each group:
   - Compute COUNT, SUM, AVG, MIN, MAX over the group
   - For column aggregations (e.g., `AVG(p.success_rate)`): resolve `p.success_rate` from bindings → payload
   - Build a `MatchResult` with projected properties = grouping key values + aggregation results
5. Return aggregated results

**Step 2d: Wire into execute_match**

In `execute_match()` (mod.rs), after collecting all results and before returning:

```rust
// VP-005: Check for aggregation in RETURN clause
if let Some(aggregated) = self.aggregate_match_results(&results, &match_clause.return_clause) {
    return Ok(aggregated);
}
```

Register module: `mod return_agg;` in `match_exec/mod.rs`

**Verify:**
```powershell
cargo test -p velesdb-core --lib match_return_agg_tests 2>&1 | Select-Object -Last 10
# All tests should pass (GREEN phase)
```

**Done when:**
- COUNT(*) returns correct count per group
- AVG/SUM/MIN/MAX compute correct values from bound node properties
- Non-aggregated RETURN items become grouping keys
- No aggregation in RETURN → behavior unchanged (regression safe)

---

### Task 3: Quality gates + commit

**Files:** All modified files

**Action:**
Run the complete quality gate suite:

```powershell
cargo fmt --all
cargo clippy -p velesdb-core -- -D warnings
cargo test -p velesdb-core --lib
cargo deny check
```

Fix any issues. Then commit:

```powershell
git add -A
git commit -m "feat(velesql): multi-hop MATCH chain + RETURN aggregation [VP-004, VP-005]

Phase 3 of v4-verify-promise milestone:

- Hop-by-hop chain execution replaces merged BFS for multi-relationship patterns
- Binding-aware WHERE evaluates alias-qualified columns against correct node
- RETURN aggregation (COUNT, AVG, SUM, MIN, MAX) with implicit grouping
- Variable-length paths use per-hop BFS depth range
- Intermediate node bindings populated at each hop

Tests: N new tests for multi-hop traversal, binding-aware WHERE, RETURN aggregation
Quality: fmt, clippy -D warnings, deny check, all tests pass"
```

**Verify:**
```powershell
cargo fmt --all --check
cargo clippy -p velesdb-core -- -D warnings
cargo test -p velesdb-core --lib
cargo deny check
```

**Done when:**
- All 5 quality gates pass (fmt, clippy, deny, test, build)
- Clean commit on branch
- No regressions in existing test suites

---

## Verification

After all tasks complete:

```powershell
cargo fmt --all --check
cargo clippy -p velesdb-core -- -D warnings
cargo test -p velesdb-core --lib multi_hop_tests
cargo test -p velesdb-core --lib match_return_agg_tests
cargo test -p velesdb-core --lib match_where_eval_tests
cargo test -p velesdb-core --lib match_exec_tests
cargo test -p velesdb-core --lib subquery_tests
cargo deny check
cargo build --release
```

## Success Criteria

- [ ] RETURN with COUNT(*) returns correct count per grouping key
- [ ] RETURN with AVG(column) computes correct average per group
- [ ] Non-aggregated RETURN items become implicit grouping keys (OpenCypher standard)
- [ ] RETURN with alias (`AS patient_count`) uses alias as result key
- [ ] No aggregation in RETURN → behavior unchanged (property projection only)
- [ ] All existing tests pass (no regression)
- [ ] At least 5 tests covering RETURN aggregation
- [ ] All quality gates pass
- [ ] No clippy warnings

## Output

**Files created:**
- `crates/velesdb-core/src/collection/search/query/match_exec/return_agg.rs` — Aggregation detection + computation
- `crates/velesdb-core/src/collection/search/query/match_return_agg_tests.rs` — Aggregation test suite

**Files modified:**
- `crates/velesdb-core/src/collection/search/query/match_exec/mod.rs` — Wire aggregation into execute_match, register module
- `crates/velesdb-core/src/collection/search/query/mod.rs` — Register test module
