---
phase: 3
plan: 1
name: Multi-hop Chain Traversal + Binding-Aware WHERE
wave: 1
depends_on: ["none"]
autonomous: true
---

# Phase 3 Plan 1: Multi-hop Chain Traversal + Binding-Aware WHERE

## Objective

Fix MATCH pattern execution to traverse multi-hop chains correctly, binding intermediate nodes at each hop, and resolve alias-qualified WHERE conditions against the correct bound node's payload. This is the core fix for VP-004.

## Context

**Requirements addressed:** VP-004
**Phase goal contribution:** Makes multi-relationship MATCH patterns functional — the primary path used by Fraud Detection (`*1..3`), Healthcare (multi-relationship), and Hero Query scenarios.

**Current state:**
- `execute_match()` in `match_exec/mod.rs` (line 123) only uses `patterns.first()` — ignores additional patterns
- `extract_rel_types(pattern)` (line 166) merges ALL relationship types into a single BFS call
- For `(a)-[:R1]->(b)-[:R2]->(c)`, BFS runs with `rel_types=[R1, R2]` and `max_depth=2` — nodes reachable by either R1 OR R2 at any depth instead of the correct R1→R2 chain
- `evaluate_where_condition(node_id, ...)` evaluates against a single node; for `WHERE b.price < 100`, it looks for key `"b.price"` in payload instead of resolving alias `b` → node_id → payload → `"price"`
- Intermediate node bindings only populated if `pattern.nodes[depth]` has an alias

**Target state:**
- Hop-by-hop execution: for each relationship in the pattern, execute a single-hop BFS from the previous hop's results, filtering by that hop's relationship types
- All intermediate nodes properly bound by their alias
- WHERE conditions with alias-qualified columns (e.g., `b.price`) resolve the alias from bindings, find the correct node, and check the property
- Variable-length hops (`*1..3`) use the range as BFS depth for that specific hop

**Research validation:**
- Neo4j's execution plan uses "Expand" operators that chain hops — output of one becomes input to next
- OpenCypher spec defines pattern matching as a chain of node→relationship→node elements
- PatMat (CIKM 2019) uses join-based pattern matching with per-hop filtering

## Tasks

### Task 1: Write failing tests for multi-hop traversal (RED)

**Files:** `crates/velesdb-core/src/collection/search/query/multi_hop_tests.rs`

**Action:**
Create a new test file with comprehensive multi-hop tests. Setup: create a collection with a graph structure like:

```
Person:Alice --[:WORKS_AT]--> Company:Acme --[:LOCATED_IN]--> City:Paris
Person:Bob   --[:WORKS_AT]--> Company:Acme --[:LOCATED_IN]--> City:Paris
Person:Carol --[:WORKS_AT]--> Company:Beta --[:LOCATED_IN]--> City:London
Person:Alice --[:FRIEND]--> Person:Bob
```

Tests:
1. **test_two_hop_chain_with_different_rel_types** — `MATCH (p:Person)-[:WORKS_AT]->(c:Company)-[:LOCATED_IN]->(city:City) RETURN p.name, c.name, city.name`
   - Should return Alice→Acme→Paris, Bob→Acme→Paris, Carol→Beta→London
   - Currently broken: BFS merges WORKS_AT + LOCATED_IN types

2. **test_two_hop_intermediate_bindings** — Verify that `c` (Company) is properly bound in results
   - Check `result.bindings["c"]` points to the correct Company node
   - Check `result.bindings["p"]` points to the correct Person node

3. **test_two_hop_where_on_intermediate_node** — `WHERE c.name = 'Acme'`
   - Should filter: only return paths through Acme (Alice→Acme→Paris, Bob→Acme→Paris)
   - Currently broken: WHERE evaluates only against final node

4. **test_single_hop_still_works** — Regression test for existing single-hop behavior
   - `MATCH (p:Person)-[:FRIEND]->(f:Person) RETURN p.name, f.name`

5. **test_variable_length_hop** — `MATCH (p:Person)-[:WORKS_AT|LOCATED_IN*1..2]->(target) RETURN target`
   - Should return nodes at depth 1 (Company) and depth 2 (City) via the correct relationship chain

Register module in `mod.rs`: `#[cfg(test)] mod multi_hop_tests;`

**Verify:**
```powershell
cargo test -p velesdb-core --lib multi_hop_tests 2>&1 | Select-Object -Last 5
# Should FAIL (RED phase) — multi-hop chain not implemented
```

**Done when:**
- Tests compile and fail with incorrect results (wrong traversal, missing bindings)

---

### Task 2: Implement hop-by-hop chain execution

**Files:** `crates/velesdb-core/src/collection/search/query/match_exec/mod.rs`

**Action:**
Refactor `execute_match()` to execute multi-hop patterns as a chain instead of a single merged BFS.

**Algorithm:**
```
1. Parse pattern into hops: [(rel_0, node_1), (rel_1, node_2), ...]
2. Start with find_start_nodes(pattern) → initial candidates
3. For each hop (rel_i, node_i+1):
   a. For each candidate from previous hop:
      - BFS from candidate.node_id with depth=1 (or rel_i.range if variable-length)
      - Filter by rel_i.types only
      - Bind node_i+1 alias to each result's target_id
   b. Collect results as new candidates for next hop
4. Final results = last hop's candidates with all accumulated bindings
```

**Key implementation details:**

1. Add a new method `execute_multi_hop_chain()`:
```rust
fn execute_multi_hop_chain(
    &self,
    pattern: &GraphPattern,
    start_candidates: Vec<(u64, HashMap<String, u64>)>,
    match_clause: &MatchClause,
    params: &HashMap<String, serde_json::Value>,
    limit: usize,
) -> Result<Vec<MatchResult>>
```

2. In `execute_match()`, detect multi-hop patterns (when `pattern.relationships.len() > 1`):
   - If single relationship: use existing BFS logic (no regression)
   - If multiple relationships: call `execute_multi_hop_chain()`

3. For each hop, use `bfs_stream()` with:
   - `max_depth` = `rel.range.map(|(_, end)| end).unwrap_or(1)` (single hop default)
   - `rel_types` = `rel.types.clone()` (per-hop filtering, not merged)
   - Start from each previous hop's target node

4. Bind intermediate node aliases at each hop step using `pattern.nodes[hop_index + 1].alias`

5. For variable-length relationships within a hop (e.g., `*1..3`), the BFS depth handles it naturally — just pass the range to `StreamingConfig.max_depth`

**Edge cases:**
- Empty intermediate results → short-circuit, return empty
- Limit enforcement: check at each hop to avoid over-computation
- Direction awareness: respect `rel.direction` per hop (outgoing vs incoming vs both)

**Verify:**
```powershell
cargo test -p velesdb-core --lib multi_hop_tests 2>&1 | Select-Object -Last 10
# Multi-hop traversal tests should pass (GREEN phase)
```

**Done when:**
- Two-hop and three-hop chain patterns traverse correctly
- Intermediate bindings populated at each hop
- Single-hop regression test still passes
- Variable-length within a hop works

---

### Task 3: Implement binding-aware WHERE evaluation

**Files:**
- `crates/velesdb-core/src/collection/search/query/match_exec/where_eval.rs`
- `crates/velesdb-core/src/collection/search/query/match_exec/mod.rs`

**Action:**
Make WHERE conditions resolve alias-qualified columns against the correct node from bindings.

**Problem:** For `WHERE c.name = 'Acme'`:
- Parser produces `Comparison { column: "c.name", operator: Eq, value: "Acme" }`
- Current `evaluate_where_condition(node_id, ...)` does `payload.get("c.name")` → None → false
- Need: resolve `"c.name"` → alias `"c"` → bindings["c"] → node_id → payload → get("name")

**Implementation:**

1. Add a new method `evaluate_where_with_bindings()` to `impl Collection`:
```rust
pub(crate) fn evaluate_where_with_bindings(
    &self,
    bindings: &HashMap<String, u64>,
    condition: &crate::velesql::Condition,
    params: &HashMap<String, serde_json::Value>,
) -> Result<bool>
```

2. For `Condition::Comparison(cmp)`:
   - If `cmp.column` contains a dot (e.g., `"c.name"`): split on first dot → `(alias, property)`
   - Look up `alias` in `bindings` to get `node_id`
   - Get payload for `node_id`, then `payload.get(property)`
   - If `cmp.column` has no dot: fall back to evaluating against ALL bound nodes (first match wins, or use the last bound node as default — matching current single-node behavior)

3. Wire `evaluate_where_with_bindings()` into `execute_multi_hop_chain()`:
   - After accumulating all bindings for a complete path, evaluate WHERE
   - Pass the full `bindings` map so any alias can be referenced

4. For `Condition::And/Or/Not/Group`: recurse with same bindings
5. For `Condition::Similarity`: keep using target node (similarity is always on the matched node's vector)
6. For other condition types (Like, Between, In, etc.): apply same alias resolution

**Backward compatibility:**
- Single-hop execution path continues to use `evaluate_where_condition(node_id, ...)` — no regression
- Multi-hop path uses `evaluate_where_with_bindings(bindings, ...)` — new behavior

**Verify:**
```powershell
cargo test -p velesdb-core --lib multi_hop_tests 2>&1 | Select-Object -Last 10
cargo test -p velesdb-core --lib match_where_eval_tests 2>&1 | Select-Object -Last 5
# All tests should pass — no regression
```

**Done when:**
- `WHERE c.name = 'Acme'` correctly filters by intermediate node property
- `WHERE p.age > 30 AND city.name = 'Paris'` works across multiple bindings
- All existing MATCH WHERE tests still pass (no regression)

---

## Verification

After all tasks complete:

```powershell
cargo fmt --all --check
cargo clippy -p velesdb-core -- -D warnings
cargo test -p velesdb-core --lib multi_hop_tests
cargo test -p velesdb-core --lib match_where_eval_tests
cargo test -p velesdb-core --lib match_exec_tests
cargo test -p velesdb-core --lib subquery_tests
```

## Success Criteria

- [ ] Multi-hop patterns `(a)-[:R1]->(b)-[:R2]->(c)` correctly traverse two relationships with per-hop type filtering
- [ ] Intermediate node bindings are populated (e.g., `b` is accessible in WHERE/RETURN)
- [ ] WHERE conditions with alias-qualified columns (`b.price`) resolve against correct bound node
- [ ] Variable-length paths within a hop use correct BFS depth range
- [ ] RETURN property projection works across all bound variables in multi-hop
- [ ] Single-hop MATCH execution has no regressions
- [ ] At least 5 tests covering multi-hop traversal with 2+ hops
- [ ] No clippy warnings

## Output

**Files created:**
- `crates/velesdb-core/src/collection/search/query/multi_hop_tests.rs` — Multi-hop test suite

**Files modified:**
- `crates/velesdb-core/src/collection/search/query/match_exec/mod.rs` — Hop-by-hop chain execution
- `crates/velesdb-core/src/collection/search/query/match_exec/where_eval.rs` — Binding-aware WHERE
- `crates/velesdb-core/src/collection/search/query/mod.rs` — Register `multi_hop_tests` module
